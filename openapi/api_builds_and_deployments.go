/*
Bitbucket Data Center

This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).

API version: 9.6
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BuildsAndDeploymentsAPIService BuildsAndDeploymentsAPI service
type BuildsAndDeploymentsAPIService service

type ApiAddRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	restBuildStatusSetRequest *RestBuildStatusSetRequest
}

// The contents of the build status request are: These fields are **required**:   - **key**: The string referring to this branch plan/job - **state**: The build status state, one of: \&quot;SUCCESSFUL\&quot;, \&quot;FAILED\&quot;, \&quot;INPROGRESS\&quot;, \&quot;CANCELLED\&quot;, \&quot;UNKNOWN\&quot; - **url**: URL referring to the build result page in the CI tool.   These fields are optional:   - **buildNumber** (optional): A unique identifier for this particular run of a plan&lt; - **dateAdded** (optional): milliseconds since epoch. If not provided current date is used. - **description** (optional): Describes the build result - **duration** (optional): Duration of a completed build in milliseconds. - **name** (optional): A short string that describes the build plan - **parent** (optional): The identifier for the plan or job that ran the branch plan that produced this build status. - **ref** (optional): The fully qualified git reference e.g. refs/heads/master. - **testResults** (optional): A summary of the passed, failed and skipped tests. 
func (r ApiAddRequest) RestBuildStatusSetRequest(restBuildStatusSetRequest RestBuildStatusSetRequest) ApiAddRequest {
	r.restBuildStatusSetRequest = &restBuildStatusSetRequest
	return r
}

func (r ApiAddRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddExecute(r)
}

/*
Add Store a build status

Store a build status.


The authenticated user must have **REPO_READ** permission for the repository that this build status is for. The request can also be made with anonymous 2-legged OAuth.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit.
 @param repositorySlug The repository slug.
 @return ApiAddRequest
*/
func (a *BuildsAndDeploymentsAPIService) Add(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiAddRequest {
	return ApiAddRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) AddExecute(r ApiAddRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.Add")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restBuildStatusSetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddAnnotationsRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key string
	restBulkAddInsightAnnotationRequest *RestBulkAddInsightAnnotationRequest
}

// The annotations to add.
func (r ApiAddAnnotationsRequest) RestBulkAddInsightAnnotationRequest(restBulkAddInsightAnnotationRequest RestBulkAddInsightAnnotationRequest) ApiAddAnnotationsRequest {
	r.restBulkAddInsightAnnotationRequest = &restBulkAddInsightAnnotationRequest
	return r
}

func (r ApiAddAnnotationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddAnnotationsExecute(r)
}

/*
AddAnnotations Add Code Insights annotations

Add annotations to the given report. The request should be a JSON object mapping the string "annotations" to an array of maps containing the annotation data, as described below. See also the example request.

A few things to note:- Annotations are an extension of a report, so a report must first exist in order to post annotations.   Annotations are posted separately from the report, and can be posted in bulk using this endpoint.
- Only the annotations that are on lines changed in the unified diff will be displayed. This means it is  likely not all annotations posted will be displayed on the pull request  It also means that if the user is viewing a side-by-side diff,  commit diff or iterative review diff they will not be able to view the annotations.
- A report cannot have more than 1000 annotations by default, however this property is congurable at an  instance level. If the request would result in more than the maximum number of annotations being stored  then the entire request is rejected and no new annotations are stored. 
- There is no de-duplication of annotations on Bitbucket so be sure that reruns of builds will first  delete the report and annotations before creating them.

# Annotation parameters

|Parameter|Description|Required?|Restrictions|Type|
|--- |--- |--- |--- |--- |
|path|The path of the file on which this annotation should be placed. This is the path of the filerelative to the git repository. If no path is provided, then it will appear in the overview modalon all pull requests where the tip of the branch is the given commit, regardless of which files weremodified.|No||String|
|line|The line number that the annotation should belong to. If no line number is provided, then it willdefault to 0 and in a pull request it will appear at the top of the file specified by the path field.|No|Non-negative integer|Integer|
|message|The message to display to users|Yes|The maximum length accepted is 2000 characters, however the user interface may truncate this valuefor display purposes. We recommend that the message is short and succinct, with further detailsavailable to the user if needed on the page linked to by the the annotation link.|String|
|severity|The severity of the annotation|Yes|One of: LOW, MEDIUM, HIGH|String|
|link|An http or https URL representing the location of the annotation in the external tool|No||String|
|type|The type of annotation posted|No|One of: VULNERABILITY, CODE_SMELL, BUG|String|
|externalId|If the caller requires a link to get or modify this annotation, then an ID must be provided. It isnot used or required by Bitbucket, but only by the annotation creator for updating or deleting thisspecific annotation.|No|A string value shorter than 450 characters|String|

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @param key The key of the report to which this annotation belongs.
 @return ApiAddAnnotationsRequest
*/
func (a *BuildsAndDeploymentsAPIService) AddAnnotations(ctx context.Context, projectKey string, commitId string, repositorySlug string, key string) ApiAddAnnotationsRequest {
	return ApiAddAnnotationsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
		key: key,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) AddAnnotationsExecute(r ApiAddAnnotationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.AddAnnotations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restBulkAddInsightAnnotationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateOrUpdateDeploymentRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	restDeploymentSetRequest *RestDeploymentSetRequest
}

// the details of the deployment to create, as detailed by the request body
func (r ApiCreateOrUpdateDeploymentRequest) RestDeploymentSetRequest(restDeploymentSetRequest RestDeploymentSetRequest) ApiCreateOrUpdateDeploymentRequest {
	r.restDeploymentSetRequest = &restDeploymentSetRequest
	return r
}

func (r ApiCreateOrUpdateDeploymentRequest) Execute() (*RestDeployment, *http.Response, error) {
	return r.ApiService.CreateOrUpdateDeploymentExecute(r)
}

/*
CreateOrUpdateDeployment Create or update a deployment

Create or update a deployment. 

 The authenticated user must have REPO_READ permission for the repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId the commitId that was deployed as indicated by the path
 @param repositorySlug The repository slug
 @return ApiCreateOrUpdateDeploymentRequest
*/
func (a *BuildsAndDeploymentsAPIService) CreateOrUpdateDeployment(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiCreateOrUpdateDeploymentRequest {
	return ApiCreateOrUpdateDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestDeployment
func (a *BuildsAndDeploymentsAPIService) CreateOrUpdateDeploymentExecute(r ApiCreateOrUpdateDeploymentRequest) (*RestDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.CreateOrUpdateDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restDeploymentSetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRequiredBuildsMergeCheckRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	repositorySlug string
	restRequiredBuildConditionSetRequest *RestRequiredBuildConditionSetRequest
}

// The request specifying the required build parent keys, ref matcher and exemption matcher
func (r ApiCreateRequiredBuildsMergeCheckRequest) RestRequiredBuildConditionSetRequest(restRequiredBuildConditionSetRequest RestRequiredBuildConditionSetRequest) ApiCreateRequiredBuildsMergeCheckRequest {
	r.restRequiredBuildConditionSetRequest = &restRequiredBuildConditionSetRequest
	return r
}

func (r ApiCreateRequiredBuildsMergeCheckRequest) Execute() (*RestRequiredBuildCondition, *http.Response, error) {
	return r.ApiService.CreateRequiredBuildsMergeCheckExecute(r)
}

/*
CreateRequiredBuildsMergeCheck Create a required builds merge check

Create a required build merge check for the given repository.

The authenticated user must have **REPO_ADMIN** permission for the target repository to register a required build merge check.

The contents of the required build merge check request are:

These fields are **required**:

- **buildParentKeys**: A non-empty list of build parent keys that require green builds for this merge check to pass
- **refMatcher.id**: The value to match refs against in the target branch
- **refMatcher.type.id**: The type of ref matcher, one of: "ANY_REF", "BRANCH", "PATTERN", "MODEL_CATEGORY" or "MODEL_BRANCH"


These fields are optional:

- **exemptRefMatcher.id** The value to exempt refs in the source branch from this check
- **exemptRefMatcher.type.id**: The type of exempt ref matcher, one of: "ANY_REF", "BRANCH", "PATTERN", "MODEL_CATEGORY" or "MODEL_BRANCH"




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project that the repository belongs to
 @param repositorySlug The repository being used
 @return ApiCreateRequiredBuildsMergeCheckRequest
*/
func (a *BuildsAndDeploymentsAPIService) CreateRequiredBuildsMergeCheck(ctx context.Context, projectKey string, repositorySlug string) ApiCreateRequiredBuildsMergeCheckRequest {
	return ApiCreateRequiredBuildsMergeCheckRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRequiredBuildCondition
func (a *BuildsAndDeploymentsAPIService) CreateRequiredBuildsMergeCheckExecute(r ApiCreateRequiredBuildsMergeCheckRequest) (*RestRequiredBuildCondition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRequiredBuildCondition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.CreateRequiredBuildsMergeCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/condition"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restRequiredBuildConditionSetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key *string
}

// the key of the build status
func (r ApiDeleteRequest) Key(key string) ApiDeleteRequest {
	r.key = &key
	return r
}

func (r ApiDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Delete a specific build status

Delete a specific build status. 

The authenticated user must have **REPO_ADMIN** permission for the provided repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit.
 @param repositorySlug The repository slug.
 @return ApiDeleteRequest
*/
func (a *BuildsAndDeploymentsAPIService) Delete(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiDeleteRequest {
	return ApiDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) DeleteExecute(r ApiDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.Delete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.key == nil {
		return nil, reportError("key is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDelete1Request struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	deploymentSequenceNumber *string
	key *string
	environmentKey *string
}

// the sequence number of the deployment, as detailed by the query parameter
func (r ApiDelete1Request) DeploymentSequenceNumber(deploymentSequenceNumber string) ApiDelete1Request {
	r.deploymentSequenceNumber = &deploymentSequenceNumber
	return r
}

// the key of the deployment, as detailed by the query parameter
func (r ApiDelete1Request) Key(key string) ApiDelete1Request {
	r.key = &key
	return r
}

// the key of the environment, as detailed by the query parameter
func (r ApiDelete1Request) EnvironmentKey(environmentKey string) ApiDelete1Request {
	r.environmentKey = &environmentKey
	return r
}

func (r ApiDelete1Request) Execute() (*http.Response, error) {
	return r.ApiService.Delete1Execute(r)
}

/*
Delete1 Delete a deployment

Delete the deployment matching the specified Repository, key, environmentKey and deploymentSequenceNumber. 

The user must have REPO_ADMIN.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId the commitId that was deployed as indicated by the path
 @param repositorySlug The repository slug
 @return ApiDelete1Request
*/
func (a *BuildsAndDeploymentsAPIService) Delete1(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiDelete1Request {
	return ApiDelete1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) Delete1Execute(r ApiDelete1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.Delete1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deploymentSequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentSequenceNumber", r.deploymentSequenceNumber, "form", "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.environmentKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environmentKey", r.environmentKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteACodeInsightsReportRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key string
}

func (r ApiDeleteACodeInsightsReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteACodeInsightsReportExecute(r)
}

/*
DeleteACodeInsightsReport Delete a Code Insights report

Delete a report for the given commit. Also deletes any annotations associated with this report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @param key The key of the report to which this annotation belongs.
 @return ApiDeleteACodeInsightsReportRequest
*/
func (a *BuildsAndDeploymentsAPIService) DeleteACodeInsightsReport(ctx context.Context, projectKey string, commitId string, repositorySlug string, key string) ApiDeleteACodeInsightsReportRequest {
	return ApiDeleteACodeInsightsReportRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
		key: key,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) DeleteACodeInsightsReportExecute(r ApiDeleteACodeInsightsReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.DeleteACodeInsightsReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAnnotationsRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key string
	externalId *string
}

// The external IDs for the annotations that are to be deleted. Can be specified more than once to delete by more than one external ID, or can be unspecified to delete all annotations.
func (r ApiDeleteAnnotationsRequest) ExternalId(externalId string) ApiDeleteAnnotationsRequest {
	r.externalId = &externalId
	return r
}

func (r ApiDeleteAnnotationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAnnotationsExecute(r)
}

/*
DeleteAnnotations Delete Code Insights annotations

Delete annotations for a given report that match the given external IDs, or all annotations if no external IDs are provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @param key The key of the report to which this annotation belongs.
 @return ApiDeleteAnnotationsRequest
*/
func (a *BuildsAndDeploymentsAPIService) DeleteAnnotations(ctx context.Context, projectKey string, commitId string, repositorySlug string, key string) ApiDeleteAnnotationsRequest {
	return ApiDeleteAnnotationsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
		key: key,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) DeleteAnnotationsExecute(r ApiDeleteAnnotationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.DeleteAnnotations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRequiredBuildsMergeCheckRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	id int64
	repositorySlug string
}

func (r ApiDeleteRequiredBuildsMergeCheckRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRequiredBuildsMergeCheckExecute(r)
}

/*
DeleteRequiredBuildsMergeCheck Delete a required builds merge check

Deletes a required build existing merge check, given it's ID.

The authenticated user must have **REPO_ADMIN** permission for the target repository to delete a required build merge check.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project that the repository belongs to
 @param id
 @param repositorySlug The repository being used
 @return ApiDeleteRequiredBuildsMergeCheckRequest
*/
func (a *BuildsAndDeploymentsAPIService) DeleteRequiredBuildsMergeCheck(ctx context.Context, projectKey string, id int64, repositorySlug string) ApiDeleteRequiredBuildsMergeCheckRequest {
	return ApiDeleteRequiredBuildsMergeCheckRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		id: id,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) DeleteRequiredBuildsMergeCheckExecute(r ApiDeleteRequiredBuildsMergeCheckRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.DeleteRequiredBuildsMergeCheck")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/condition/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key *string
}

// the key of the build status
func (r ApiGetRequest) Key(key string) ApiGetRequest {
	r.key = &key
	return r
}

func (r ApiGetRequest) Execute() (*RestBuildStatus, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Get a specific build status

Get a specific build status.


The authenticated user must have **REPO_READ** permission for the provided repository.The request can also be made with anonymous 2-legged OAuth.<br>Since 7.14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit.
 @param repositorySlug The repository slug.
 @return ApiGetRequest
*/
func (a *BuildsAndDeploymentsAPIService) Get(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGetRequest {
	return ApiGetRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestBuildStatus
func (a *BuildsAndDeploymentsAPIService) GetExecute(r ApiGetRequest) (*RestBuildStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestBuildStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.key == nil {
		return localVarReturnValue, nil, reportError("key is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGet1Request struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	deploymentSequenceNumber *string
	key *string
	environmentKey *string
}

// the sequence number of the deployment, as detailed by the query param
func (r ApiGet1Request) DeploymentSequenceNumber(deploymentSequenceNumber string) ApiGet1Request {
	r.deploymentSequenceNumber = &deploymentSequenceNumber
	return r
}

// the key of the deployment, as detailed by the query parameter
func (r ApiGet1Request) Key(key string) ApiGet1Request {
	r.key = &key
	return r
}

// the key of the environment, as detailed by the query parameter
func (r ApiGet1Request) EnvironmentKey(environmentKey string) ApiGet1Request {
	r.environmentKey = &environmentKey
	return r
}

func (r ApiGet1Request) Execute() (*RestDeployment, *http.Response, error) {
	return r.ApiService.Get1Execute(r)
}

/*
Get1 Get a deployment

Get the deployment matching the specified Repository, key, environmentKey and deploymentSequenceNumber. 

The user must have REPO_READ.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId the commitId that was deployed as indicated by the query parameter
 @param repositorySlug The repository slug
 @return ApiGet1Request
*/
func (a *BuildsAndDeploymentsAPIService) Get1(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGet1Request {
	return ApiGet1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestDeployment
func (a *BuildsAndDeploymentsAPIService) Get1Execute(r ApiGet1Request) (*RestDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.Get1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deploymentSequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentSequenceNumber", r.deploymentSequenceNumber, "form", "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.environmentKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environmentKey", r.environmentKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetACodeInsightsReportRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key string
}

func (r ApiGetACodeInsightsReportRequest) Execute() (*RestInsightReport, *http.Response, error) {
	return r.ApiService.GetACodeInsightsReportExecute(r)
}

/*
GetACodeInsightsReport Get a Code Insights report

Retrieve the specified report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @param key The report key.
 @return ApiGetACodeInsightsReportRequest
*/
func (a *BuildsAndDeploymentsAPIService) GetACodeInsightsReport(ctx context.Context, projectKey string, commitId string, repositorySlug string, key string) ApiGetACodeInsightsReportRequest {
	return ApiGetACodeInsightsReportRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
		key: key,
	}
}

// Execute executes the request
//  @return RestInsightReport
func (a *BuildsAndDeploymentsAPIService) GetACodeInsightsReportExecute(r ApiGetACodeInsightsReportRequest) (*RestInsightReport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestInsightReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.GetACodeInsightsReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAnnotationsRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key string
}

func (r ApiGetAnnotationsRequest) Execute() (*RestInsightAnnotationsResponse, *http.Response, error) {
	return r.ApiService.GetAnnotationsExecute(r)
}

/*
GetAnnotations Get Code Insights annotations for a report

Retrieve the specified report's annotations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @param key The report key.
 @return ApiGetAnnotationsRequest
*/
func (a *BuildsAndDeploymentsAPIService) GetAnnotations(ctx context.Context, projectKey string, commitId string, repositorySlug string, key string) ApiGetAnnotationsRequest {
	return ApiGetAnnotationsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
		key: key,
	}
}

// Execute executes the request
//  @return RestInsightAnnotationsResponse
func (a *BuildsAndDeploymentsAPIService) GetAnnotationsExecute(r ApiGetAnnotationsRequest) (*RestInsightAnnotationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestInsightAnnotationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.GetAnnotations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAnnotations1Request struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	severity *string
	path *string
	externalId *string
	type_ *string
	key *string
}

// Return only annotations that have one of the given severities. Can be specified more than once to filter by more than one severity. Valid severities are &lt;code&gt;LOW&lt;/code&gt;, &lt;code&gt;MEDIUM&lt;/code&gt; and &lt;code&gt;HIGH&lt;/code&gt;.
func (r ApiGetAnnotations1Request) Severity(severity string) ApiGetAnnotations1Request {
	r.severity = &severity
	return r
}

// Return only annotations that appear on one of the provided paths. Can be specified more than once to filter by more than one path.
func (r ApiGetAnnotations1Request) Path(path string) ApiGetAnnotations1Request {
	r.path = &path
	return r
}

// Return only annotations that have one of the provided external IDs. Can be specified more than once to filter by more than one external ID.
func (r ApiGetAnnotations1Request) ExternalId(externalId string) ApiGetAnnotations1Request {
	r.externalId = &externalId
	return r
}

// Return only annotations that have one of the given types. Can be specified more than once to filter by multiple types. Valid types are &lt;code&gt;BUG&lt;/code&gt;, &lt;code&gt;CODE_SMELL&lt;/code&gt;, and &lt;code&gt;VULNERABILITY&lt;/code&gt;.
func (r ApiGetAnnotations1Request) Type_(type_ string) ApiGetAnnotations1Request {
	r.type_ = &type_
	return r
}

// Return only annotations that belong to one of the provided report keys. Can be specified more than once to filter by more than one report
func (r ApiGetAnnotations1Request) Key(key string) ApiGetAnnotations1Request {
	r.key = &key
	return r
}

func (r ApiGetAnnotations1Request) Execute() (*RestInsightAnnotationsResponse, *http.Response, error) {
	return r.ApiService.GetAnnotations1Execute(r)
}

/*
GetAnnotations1 Get Code Insights annotations for a commit

Get annotations for the given commit ID, filtered by any query parameters given.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @return ApiGetAnnotations1Request
*/
func (a *BuildsAndDeploymentsAPIService) GetAnnotations1(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGetAnnotations1Request {
	return ApiGetAnnotations1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestInsightAnnotationsResponse
func (a *BuildsAndDeploymentsAPIService) GetAnnotations1Execute(r ApiGetAnnotations1Request) (*RestInsightAnnotationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestInsightAnnotationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.GetAnnotations1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBuildStatusStatsRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	commitId string
	includeUnique *bool
}

// include a unique build result if there is either only one failed build, only one in-progress build or only one successful build
func (r ApiGetBuildStatusStatsRequest) IncludeUnique(includeUnique bool) ApiGetBuildStatusStatsRequest {
	r.includeUnique = &includeUnique
	return r
}

func (r ApiGetBuildStatusStatsRequest) Execute() (*RestBuildStats, *http.Response, error) {
	return r.ApiService.GetBuildStatusStatsExecute(r)
}

/*
GetBuildStatusStats Get build status statistics for commit

Gets statistics regarding the builds associated with a commit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commitId full SHA1 of the commit
 @return ApiGetBuildStatusStatsRequest
*/
func (a *BuildsAndDeploymentsAPIService) GetBuildStatusStats(ctx context.Context, commitId string) ApiGetBuildStatusStatsRequest {
	return ApiGetBuildStatusStatsRequest{
		ApiService: a,
		ctx: ctx,
		commitId: commitId,
	}
}

// Execute executes the request
//  @return RestBuildStats
func (a *BuildsAndDeploymentsAPIService) GetBuildStatusStatsExecute(r ApiGetBuildStatusStatsRequest) (*RestBuildStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestBuildStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.GetBuildStatusStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/build-status/latest/commits/stats/{commitId}"
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeUnique != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUnique", r.includeUnique, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMultipleBuildStatusStatsRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	requestBody *[]string
}

// full SHA1 of each commit
func (r ApiGetMultipleBuildStatusStatsRequest) RequestBody(requestBody []string) ApiGetMultipleBuildStatusStatsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGetMultipleBuildStatusStatsRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetMultipleBuildStatusStatsExecute(r)
}

/*
GetMultipleBuildStatusStats Get build status statistics for multiple commits

Produces a list of the build statistics for multiple commits. Commits <em>without any builds associated with them</em> will not be returned.<br> For example if the commit <code>e00cf62997a027bbf785614a93e2e55bb331d268</code> does not have any build statuses associated with it, it will not be present in the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMultipleBuildStatusStatsRequest
*/
func (a *BuildsAndDeploymentsAPIService) GetMultipleBuildStatusStats(ctx context.Context) ApiGetMultipleBuildStatusStatsRequest {
	return ApiGetMultipleBuildStatusStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BuildsAndDeploymentsAPIService) GetMultipleBuildStatusStatsExecute(r ApiGetMultipleBuildStatusStatsRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.GetMultipleBuildStatusStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/build-status/latest/commits/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageOfRequiredBuildsMergeChecksRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	repositorySlug string
	start *float32
	limit *float32
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetPageOfRequiredBuildsMergeChecksRequest) Start(start float32) ApiGetPageOfRequiredBuildsMergeChecksRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetPageOfRequiredBuildsMergeChecksRequest) Limit(limit float32) ApiGetPageOfRequiredBuildsMergeChecksRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPageOfRequiredBuildsMergeChecksRequest) Execute() (*GetPageOfRequiredBuildsMergeChecks200Response, *http.Response, error) {
	return r.ApiService.GetPageOfRequiredBuildsMergeChecksExecute(r)
}

/*
GetPageOfRequiredBuildsMergeChecks Get required builds merge checks

Returns a page of required build merge checks that have been configured for this repository.

The authenticated user must have **REPO_READ** permission for the target repository to request a page of required build merge checks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project that the repository belongs to
 @param repositorySlug The repository being used
 @return ApiGetPageOfRequiredBuildsMergeChecksRequest
*/
func (a *BuildsAndDeploymentsAPIService) GetPageOfRequiredBuildsMergeChecks(ctx context.Context, projectKey string, repositorySlug string) ApiGetPageOfRequiredBuildsMergeChecksRequest {
	return ApiGetPageOfRequiredBuildsMergeChecksRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetPageOfRequiredBuildsMergeChecks200Response
func (a *BuildsAndDeploymentsAPIService) GetPageOfRequiredBuildsMergeChecksExecute(r ApiGetPageOfRequiredBuildsMergeChecksRequest) (*GetPageOfRequiredBuildsMergeChecks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPageOfRequiredBuildsMergeChecks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.GetPageOfRequiredBuildsMergeChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/conditions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportsRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	start *float32
	limit *float32
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetReportsRequest) Start(start float32) ApiGetReportsRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetReportsRequest) Limit(limit float32) ApiGetReportsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetReportsRequest) Execute() (*GetReports200Response, *http.Response, error) {
	return r.ApiService.GetReportsExecute(r)
}

/*
GetReports Get all Code Insights reports for a commit

Retrieve all reports for the given commit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @return ApiGetReportsRequest
*/
func (a *BuildsAndDeploymentsAPIService) GetReports(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGetReportsRequest {
	return ApiGetReportsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetReports200Response
func (a *BuildsAndDeploymentsAPIService) GetReportsExecute(r ApiGetReportsRequest) (*GetReports200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReports200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.GetReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetACodeInsightsReportRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	commitId string
	repositorySlug string
	key string
	restSetInsightReportRequest *RestSetInsightReportRequest
}

// The request object containing the details of the report to create (see example).
func (r ApiSetACodeInsightsReportRequest) RestSetInsightReportRequest(restSetInsightReportRequest RestSetInsightReportRequest) ApiSetACodeInsightsReportRequest {
	r.restSetInsightReportRequest = &restSetInsightReportRequest
	return r
}

func (r ApiSetACodeInsightsReportRequest) Execute() (*RestInsightReport, *http.Response, error) {
	return r.ApiService.SetACodeInsightsReportExecute(r)
}

/*
SetACodeInsightsReport Create a Code Insights report

Create a new insight report, or replace the existing one if a report already exists for the given repository, commit, and report key. A request to replace an existing report will be rejected if the authenticated user was not the creator of the specified report.

The report key should be a unique string chosen by the reporter and should be unique enough not to potentially clash with report keys from other reporters. We recommend using reverse DNS namespacing or a similar standard to ensure that collision is avoided.<h1>Report parameters</h1><table summary="Report parameters">    <tr>        <th>Parameter</th>        <th>Description</th>        <th>Required?</th>        <th>Restrictions</th>        <th>Type</th>    </tr>    <tr>        <td>title</td>        <td>A short string representing the name of the report</td>        <td>Yes</td>        <td>Max length: 450 characters (but we recommend that it is shorter so that the display is nicer)</td>        <td>String</td>    </tr>    <tr>        <td>details</td>        <td>             A string to describe the purpose of the report. This string may contain             escaped newlines and if it does it will display the content accordingly.        </td>        <td>No</td>        <td>Max length: 2000 characters</td>        <td>String</td>    </tr>    <tr>        <td>result</td>        <td>Indicates whether the report is in a passed or failed state</td>        <td>No</td>        <td>One of: PASS, FAIL</td>        <td>String</td>    </tr>    <tr>        <td>data</td>        <td>An array of data fields (described below) to display information on the report</td>        <td>No</td>        <td>Maximum 6 data fields</td>        <td>Array</td>    </tr>    <tr>        <td>reporter</td>        <td>A string to describe the tool or company who created the report</td>        <td>No</td>        <td>Max length: 450 characters</td>        <td>String</td>    </tr>    <tr>        <td>link</td>        <td>A URL linking to the results of the report in an external tool.</td>        <td>No</td>        <td>Must be a valid http or https URL</td>        <td>String</td>    </tr>    <tr>        <td>logoUrl</td>        <td>A URL to the report logo. If none is provided, the default insights logo will be used.</td>        <td>No</td>        <td>Must be a valid http or https URL</td>        <td>String</td>    </tr></table><h1>Data parameters</h1>The data field on the report is an array with at most 6 data fields (JSON maps) containing information that is to be displayed on the report (see the request example).<table summary="Data parameters">    <tr>        <th>Parameter</th>        <th>Description</th>        <th>Type</th>    </tr>    <tr>        <td>title</td>        <td>A string describing what this data field represents</td>        <td>String</td>    </tr>    <tr>        <td>type</td>        <td>             The type of data contained in the value field. If not provided,             then the value will be detected as a boolean, number or string.             One of: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT        </td>        <td>String</td>    </tr>    <tr>        <td>value</td>        <td>            A value based on the type provided. Either a raw value             (string, number or boolean) or a map. See below.        </td>    </tr></table><table summary="Types">    <tr>        <th>Type Field</th>        <th>Value Field Type</th>        <th>Value Field Display</th>    </tr>    <tr>        <td>None/Omitted</td>        <td>Number, String or Boolean (not an array or object)</td>        <td>Plain text</td>    </tr>    <tr>        <td>BOOLEAN</td>        <td>Boolean</td>        <td>The value will be read as a JSON boolean and displayed as 'Yes' or 'No'.</td>    </tr>    <tr>        <td>DATE</td>        <td>Number</td>        <td>             The value will be read as a JSON number in the form of a Unix timestamp              (milliseconds) and will be displayed as a relative date if the date is less             than one week ago, otherwise it will be displayed as an absolute date.        </td>    </tr>    <tr>        <td>DURATION</td>        <td>Number</td>        <td>             The value will be read as a JSON number in milliseconds and             will be displayed in a human readable duration format.        </td>    </tr>    <tr>        <td>LINK</td>        <td>Object: {"linktext": "Link text here", "href": "https://link.to.annotation/in/external/tool"}</td>        <td>             The value will be read as a JSON object containing the fields "linktext"             and "href" and will be displayed as a clickable link on the report.        </td>    </tr>    <tr>        <td>NUMBER</td>        <td>Number</td>        <td>             The value will be read as a JSON number and large numbers will             be displayed in a human readable format (e.g. 14.3k).        </td>    </tr>    <tr>        <td>PERCENTAGE</td>        <td>Number (between 0 and 100)</td>        <td>             The value will be read as a JSON number between 0 and 100              and will be displayed with a percentage sign.        </td>    </tr>    <tr>        <td>TEXT</td>        <td>String</td>        <td>The value will be read as a JSON string and will be displayed as-is</td>    </tr></table>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @param key A unique string representing the report as chosen by the reporter. This should be unique enough to not clash with other report's keys. To do this, we recommend namespacing the key using reverse DNS
 @return ApiSetACodeInsightsReportRequest
*/
func (a *BuildsAndDeploymentsAPIService) SetACodeInsightsReport(ctx context.Context, projectKey string, commitId string, repositorySlug string, key string) ApiSetACodeInsightsReportRequest {
	return ApiSetACodeInsightsReportRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
		key: key,
	}
}

// Execute executes the request
//  @return RestInsightReport
func (a *BuildsAndDeploymentsAPIService) SetACodeInsightsReportExecute(r ApiSetACodeInsightsReportRequest) (*RestInsightReport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestInsightReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.SetACodeInsightsReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restSetInsightReportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetAnnotationRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	externalId string
	commitId string
	repositorySlug string
	key string
	restSingleAddInsightAnnotationRequest *RestSingleAddInsightAnnotationRequest
}

// The new annotation that is to replace the existing one.
func (r ApiSetAnnotationRequest) RestSingleAddInsightAnnotationRequest(restSingleAddInsightAnnotationRequest RestSingleAddInsightAnnotationRequest) ApiSetAnnotationRequest {
	r.restSingleAddInsightAnnotationRequest = &restSingleAddInsightAnnotationRequest
	return r
}

func (r ApiSetAnnotationRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAnnotationExecute(r)
}

/*
SetAnnotation Create or replace a Code Insights annotation

Create an annotation with the given external ID, or replace it if it already exists. A request to replace an existing annotation will be rejected if the authenticated user was not the creator of the specified report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param externalId The external ID of the annotation that is to be updated or created
 @param commitId The commit ID on which to record the annotation. This must be a full 40 character commit hash.
 @param repositorySlug The repository slug.
 @param key The key of the report to which this annotation belongs
 @return ApiSetAnnotationRequest
*/
func (a *BuildsAndDeploymentsAPIService) SetAnnotation(ctx context.Context, projectKey string, externalId string, commitId string, repositorySlug string, key string) ApiSetAnnotationRequest {
	return ApiSetAnnotationRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		externalId: externalId,
		commitId: commitId,
		repositorySlug: repositorySlug,
		key: key,
	}
}

// Execute executes the request
func (a *BuildsAndDeploymentsAPIService) SetAnnotationExecute(r ApiSetAnnotationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.SetAnnotation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations/{externalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalId"+"}", url.PathEscape(parameterValueToString(r.externalId, "externalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restSingleAddInsightAnnotationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRequiredBuildsMergeCheckRequest struct {
	ctx context.Context
	ApiService *BuildsAndDeploymentsAPIService
	projectKey string
	id int64
	repositorySlug string
	restRequiredBuildConditionSetRequest *RestRequiredBuildConditionSetRequest
}

// The request specifying the required build parent keys, ref matcher and exemption matcher
func (r ApiUpdateRequiredBuildsMergeCheckRequest) RestRequiredBuildConditionSetRequest(restRequiredBuildConditionSetRequest RestRequiredBuildConditionSetRequest) ApiUpdateRequiredBuildsMergeCheckRequest {
	r.restRequiredBuildConditionSetRequest = &restRequiredBuildConditionSetRequest
	return r
}

func (r ApiUpdateRequiredBuildsMergeCheckRequest) Execute() (*RestRequiredBuildCondition, *http.Response, error) {
	return r.ApiService.UpdateRequiredBuildsMergeCheckExecute(r)
}

/*
UpdateRequiredBuildsMergeCheck Update a required builds merge check

Update the required builds merge check for the given ID.

The authenticated user must have **REPO_ADMIN** permission for the target repository to update a required build merge check.

The contents of the required build merge check request are:

These fields are **required**:

- **buildParentKeys**: A non-empty list of build parent keys that require green builds for this merge check to pass
- **refMatcher.id**: The value to match refs against in the target branch
- **refMatcher.type.id**: The type of ref matcher, one of: "ANY_REF", "BRANCH", "PATTERN", "MODEL_CATEGORY" or "MODEL_BRANCH"


These fields are optional:

- **exemptRefMatcher.id** The value to exempt refs in the source branch from this check
- **exemptRefMatcher.type.id**: The type of exempt ref matcher, one of: "ANY_REF", "BRANCH", "PATTERN", "MODEL_CATEGORY" or "MODEL_BRANCH"




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project that the repository belongs to
 @param id
 @param repositorySlug The repository being used
 @return ApiUpdateRequiredBuildsMergeCheckRequest
*/
func (a *BuildsAndDeploymentsAPIService) UpdateRequiredBuildsMergeCheck(ctx context.Context, projectKey string, id int64, repositorySlug string) ApiUpdateRequiredBuildsMergeCheckRequest {
	return ApiUpdateRequiredBuildsMergeCheckRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		id: id,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRequiredBuildCondition
func (a *BuildsAndDeploymentsAPIService) UpdateRequiredBuildsMergeCheckExecute(r ApiUpdateRequiredBuildsMergeCheckRequest) (*RestRequiredBuildCondition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRequiredBuildCondition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildsAndDeploymentsAPIService.UpdateRequiredBuildsMergeCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/condition/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restRequiredBuildConditionSetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
