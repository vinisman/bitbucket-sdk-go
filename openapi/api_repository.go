/*
Bitbucket Data Center

This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).

API version: 9.6
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RepositoryAPIService RepositoryAPI service
type RepositoryAPIService service

type ApiAddDefaultTask1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restDefaultTaskRequest *RestDefaultTaskRequest
}

// The task to be added
func (r ApiAddDefaultTask1Request) RestDefaultTaskRequest(restDefaultTaskRequest RestDefaultTaskRequest) ApiAddDefaultTask1Request {
	r.restDefaultTaskRequest = &restDefaultTaskRequest
	return r
}

func (r ApiAddDefaultTask1Request) Execute() (*RestDefaultTask, *http.Response, error) {
	return r.ApiService.AddDefaultTask1Execute(r)
}

/*
AddDefaultTask1 Add a default task

Creates a default task for the supplied repository.

The authenticated user must have **REPO_ADMIN** permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiAddDefaultTask1Request
*/
func (a *RepositoryAPIService) AddDefaultTask1(ctx context.Context, projectKey string, repositorySlug string) ApiAddDefaultTask1Request {
	return ApiAddDefaultTask1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestDefaultTask
func (a *RepositoryAPIService) AddDefaultTask1Execute(r ApiAddDefaultTask1Request) (*RestDefaultTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDefaultTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.AddDefaultTask1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/default-tasks/latest/projects/{projectKey}/repos/{repositorySlug}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restDefaultTaskRequest == nil {
		return localVarReturnValue, nil, reportError("restDefaultTaskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restDefaultTaskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddLabelRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restLabel *RestLabel
}

// The label to apply
func (r ApiAddLabelRequest) RestLabel(restLabel RestLabel) ApiAddLabelRequest {
	r.restLabel = &restLabel
	return r
}

func (r ApiAddLabelRequest) Execute() (*RestLabel, *http.Response, error) {
	return r.ApiService.AddLabelExecute(r)
}

/*
AddLabel Add repository label

Applies a label to the repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiAddLabelRequest
*/
func (a *RepositoryAPIService) AddLabel(ctx context.Context, projectKey string, repositorySlug string) ApiAddLabelRequest {
	return ApiAddLabelRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestLabel
func (a *RepositoryAPIService) AddLabelExecute(r ApiAddLabelRequest) (*RestLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.AddLabel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restLabel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBranchRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restBranchCreateRequest *RestBranchCreateRequest
}

func (r ApiCreateBranchRequest) RestBranchCreateRequest(restBranchCreateRequest RestBranchCreateRequest) ApiCreateBranchRequest {
	r.restBranchCreateRequest = &restBranchCreateRequest
	return r
}

func (r ApiCreateBranchRequest) Execute() (*RestBranch, *http.Response, error) {
	return r.ApiService.CreateBranchExecute(r)
}

/*
CreateBranch Create branch

 Creates a branch in the specified repository.


The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource. If
branch permissions are set up in the repository, the authenticated user must also have access to the branch name
that is to be created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiCreateBranchRequest
*/
func (a *RepositoryAPIService) CreateBranch(ctx context.Context, projectKey string, repositorySlug string) ApiCreateBranchRequest {
	return ApiCreateBranchRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestBranch
func (a *RepositoryAPIService) CreateBranchExecute(r ApiCreateBranchRequest) (*RestBranch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestBranch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.CreateBranch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restBranchCreateRequest == nil {
		return localVarReturnValue, nil, reportError("restBranchCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restBranchCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBranchForRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restCreateBranchRequest *RestCreateBranchRequest
}

// The request to create a branch containing a &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;startPoint&lt;/strong&gt;, and optionally a &lt;strong&gt;message&lt;/strong&gt;
func (r ApiCreateBranchForRepositoryRequest) RestCreateBranchRequest(restCreateBranchRequest RestCreateBranchRequest) ApiCreateBranchForRepositoryRequest {
	r.restCreateBranchRequest = &restCreateBranchRequest
	return r
}

func (r ApiCreateBranchForRepositoryRequest) Execute() (*RestBranch, *http.Response, error) {
	return r.ApiService.CreateBranchForRepositoryExecute(r)
}

/*
CreateBranchForRepository Create branch

Creates a branch using the information provided in the RestCreateBranchRequest request 

The authenticated user must have <strong>REPO_WRITE</strong> permission for the context repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiCreateBranchForRepositoryRequest
*/
func (a *RepositoryAPIService) CreateBranchForRepository(ctx context.Context, projectKey string, repositorySlug string) ApiCreateBranchForRepositoryRequest {
	return ApiCreateBranchForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestBranch
func (a *RepositoryAPIService) CreateBranchForRepositoryExecute(r ApiCreateBranchForRepositoryRequest) (*RestBranch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestBranch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.CreateBranchForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restCreateBranchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCommentRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
	since *string
	restComment *RestComment
}

// For a merge commit, a parent can be provided to specify which diff the comments should be on. For a commit range, a sinceId can be provided to specify where the comments should be anchored from.
func (r ApiCreateCommentRequest) Since(since string) ApiCreateCommentRequest {
	r.since = &since
	return r
}

// the comment
func (r ApiCreateCommentRequest) RestComment(restComment RestComment) ApiCreateCommentRequest {
	r.restComment = &restComment
	return r
}

func (r ApiCreateCommentRequest) Execute() (*RestComment, *http.Response, error) {
	return r.ApiService.CreateCommentExecute(r)
}

/*
CreateComment Add a new commit comment

Add a new comment.

Comments can be added in a few places by setting different attributes:

General commit comment:

```{
      "text": "An insightful general comment on a commit."
}

</pre>
Reply to a comment:
<pre>{
      "text": "A measured reply.",
      "parent": {
          "id": 1
      }
}
</pre>
General file comment:
<pre>{
      "text": "An insightful general comment on a file.",
      "anchor": {
          "diffType": "COMMIT",
          "fromHash": "6df3858eeb9a53a911cd17e66a9174d44ffb02cd",
          "path": "path/to/file",
          "srcPath": "path/to/file",
          "toHash": "04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b"
      }
}
</pre>
File line comment:
<pre>{
      "text": "A pithy comment on a particular line within a file.",
      "anchor": {
          "diffType": "COMMIT",
          "line": 1,
          "lineType": "CONTEXT",
          "fileType": "FROM",
          "fromHash": "6df3858eeb9a53a911cd17e66a9174d44ffb02cd",
          "path": "path/to/file",
          "srcPath": "path/to/file",
          "toHash": "04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b"
      }
}
```

Note: general file comments are an experimental feature and may change in the near future!

For file and line comments, 'path' refers to the path of the file to which the comment should be applied and 'srcPath' refers to the path the that file used to have (only required for copies and moves). Also, fromHash and toHash refer to the sinceId / untilId (respectively) used to produce the diff on which the comment was added. fromHash will be resolved automatically as first parent if not specified. Note that this behaviour differs from `/pull-requests/comments`

Finally diffType refers to the type of diff the comment was added on.

For line comments, 'line' refers to the line in the diff that the comment should apply to. 'lineType' refers to the type of diff hunk, which can be:- 'ADDED' - for an added line;</li>- 'REMOVED' - for a removed line; or</li>- 'CONTEXT' - for a line that was unmodified but is in the vicinity of the diff.</li>'fileType' refers to the file of the diff to which the anchor should be attached - which is of relevance when displaying the diff in a side-by-side way. Currently the supported values are:- 'FROM' - the source file of the diff</li>- 'TO' - the destination file of the diff</li>If the current user is not a participant the user is added as one and updated to watch the commit.

The authenticated user must have REPO_READ permission for the repository that the commit is in to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiCreateCommentRequest
*/
func (a *RepositoryAPIService) CreateComment(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiCreateCommentRequest {
	return ApiCreateCommentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestComment
func (a *RepositoryAPIService) CreateCommentExecute(r ApiCreateCommentRequest) (*RestComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.CreateComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRestrictions1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restRestrictionRequest *[]RestRestrictionRequest
}

// The request containing a list of the details of the restrictions to create.
func (r ApiCreateRestrictions1Request) RestRestrictionRequest(restRestrictionRequest []RestRestrictionRequest) ApiCreateRestrictions1Request {
	r.restRestrictionRequest = &restRestrictionRequest
	return r
}

func (r ApiCreateRestrictions1Request) Execute() (*RestRefRestriction, *http.Response, error) {
	return r.ApiService.CreateRestrictions1Execute(r)
}

/*
CreateRestrictions1 Create multiple ref restrictions

Allows creating multiple restrictions at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiCreateRestrictions1Request
*/
func (a *RepositoryAPIService) CreateRestrictions1(ctx context.Context, projectKey string, repositorySlug string) ApiCreateRestrictions1Request {
	return ApiCreateRestrictions1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRefRestriction
func (a *RepositoryAPIService) CreateRestrictions1Execute(r ApiCreateRestrictions1Request) (*RestRefRestriction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRefRestriction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.CreateRestrictions1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.atl.bitbucket.bulk+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restRestrictionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTagRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restGitTagCreateRequest *RestGitTagCreateRequest
}

// The create git tag request.
func (r ApiCreateTagRequest) RestGitTagCreateRequest(restGitTagCreateRequest RestGitTagCreateRequest) ApiCreateTagRequest {
	r.restGitTagCreateRequest = &restGitTagCreateRequest
	return r
}

func (r ApiCreateTagRequest) Execute() (*RestTag, *http.Response, error) {
	return r.ApiService.CreateTagExecute(r)
}

/*
CreateTag Create tag

Creates a tag in the specified repository.

The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource.

'LIGHTWEIGHT' and 'ANNOTATED' are the two type of tags that can be created. The 'startPoint' can either be a ref or a 'commit'.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiCreateTagRequest
*/
func (a *RepositoryAPIService) CreateTag(ctx context.Context, projectKey string, repositorySlug string) ApiCreateTagRequest {
	return ApiCreateTagRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestTag
func (a *RepositoryAPIService) CreateTagExecute(r ApiCreateTagRequest) (*RestTag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestTag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.CreateTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restGitTagCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTagForRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restCreateTagRequest *RestCreateTagRequest
}

// The request to create a tag containing a &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;startPoint&lt;/strong&gt;, and optionally a &lt;strong&gt;message&lt;/strong&gt;
func (r ApiCreateTagForRepositoryRequest) RestCreateTagRequest(restCreateTagRequest RestCreateTagRequest) ApiCreateTagForRepositoryRequest {
	r.restCreateTagRequest = &restCreateTagRequest
	return r
}

func (r ApiCreateTagForRepositoryRequest) Execute() (*RestTag, *http.Response, error) {
	return r.ApiService.CreateTagForRepositoryExecute(r)
}

/*
CreateTagForRepository Create tag

Creates a tag using the information provided in the RestCreateTagRequest request 

The authenticated user must have <strong>REPO_WRITE</strong> permission for the context repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiCreateTagForRepositoryRequest
*/
func (a *RepositoryAPIService) CreateTagForRepository(ctx context.Context, projectKey string, repositorySlug string) ApiCreateTagForRepositoryRequest {
	return ApiCreateTagForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestTag
func (a *RepositoryAPIService) CreateTagForRepositoryExecute(r ApiCreateTagForRepositoryRequest) (*RestTag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestTag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.CreateTagForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restCreateTagRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWebhook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restWebhook *RestWebhook
}

// The webhook to be created for this repository.
func (r ApiCreateWebhook1Request) RestWebhook(restWebhook RestWebhook) ApiCreateWebhook1Request {
	r.restWebhook = &restWebhook
	return r
}

func (r ApiCreateWebhook1Request) Execute() (*RestWebhook, *http.Response, error) {
	return r.ApiService.CreateWebhook1Execute(r)
}

/*
CreateWebhook1 Create webhook

Create a webhook for the repository specified via the URL. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiCreateWebhook1Request
*/
func (a *RepositoryAPIService) CreateWebhook1(ctx context.Context, projectKey string, repositorySlug string) ApiCreateWebhook1Request {
	return ApiCreateWebhook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestWebhook
func (a *RepositoryAPIService) CreateWebhook1Execute(r ApiCreateWebhook1Request) (*RestWebhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestWebhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.CreateWebhook1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restWebhook
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDelete5Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiDelete5Request) Execute() (*http.Response, error) {
	return r.ApiService.Delete5Execute(r)
}

/*
Delete5 Delete pull request auto-merge settings

Deletes pull request auto-merge settings for the supplied repository.

The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiDelete5Request
*/
func (a *RepositoryAPIService) Delete5(ctx context.Context, projectKey string, repositorySlug string) ApiDelete5Request {
	return ApiDelete5Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) Delete5Execute(r ApiDelete5Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Delete5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAllDefaultTasks1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiDeleteAllDefaultTasks1Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAllDefaultTasks1Execute(r)
}

/*
DeleteAllDefaultTasks1 Deletes all default tasks for the repository

Delete all the default tasks for the supplied repository

The authenticated user must have **REPO_ADMIN** permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiDeleteAllDefaultTasks1Request
*/
func (a *RepositoryAPIService) DeleteAllDefaultTasks1(ctx context.Context, projectKey string, repositorySlug string) ApiDeleteAllDefaultTasks1Request {
	return ApiDeleteAllDefaultTasks1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteAllDefaultTasks1Execute(r ApiDeleteAllDefaultTasks1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteAllDefaultTasks1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/default-tasks/latest/projects/{projectKey}/repos/{repositorySlug}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAttachmentRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	attachmentId string
	repositorySlug string
}

func (r ApiDeleteAttachmentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAttachmentExecute(r)
}

/*
DeleteAttachment Delete an attachment

Delete an attachment.

The user must be authenticated and have <strong>REPO_ADMIN</strong> permission for the specified repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param attachmentId the attachment ID
 @param repositorySlug The repository slug
 @return ApiDeleteAttachmentRequest
*/
func (a *RepositoryAPIService) DeleteAttachment(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) ApiDeleteAttachmentRequest {
	return ApiDeleteAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		attachmentId: attachmentId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteAttachmentExecute(r ApiDeleteAttachmentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteAttachment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAttachmentMetadataRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	attachmentId string
	repositorySlug string
}

func (r ApiDeleteAttachmentMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAttachmentMetadataExecute(r)
}

/*
DeleteAttachmentMetadata Delete attachment metadata

Delete attachment metadata.

The user must be authenticated and have <strong>REPO_ADMIN</strong> permission for the specified repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param attachmentId the attachment ID
 @param repositorySlug The repository slug
 @return ApiDeleteAttachmentMetadataRequest
*/
func (a *RepositoryAPIService) DeleteAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) ApiDeleteAttachmentMetadataRequest {
	return ApiDeleteAttachmentMetadataRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		attachmentId: attachmentId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteAttachmentMetadataExecute(r ApiDeleteAttachmentMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteAttachmentMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAutoDeclineSettings1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiDeleteAutoDeclineSettings1Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAutoDeclineSettings1Execute(r)
}

/*
DeleteAutoDeclineSettings1 Delete auto decline settings

Delete auto decline settings for the supplied repository.

The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiDeleteAutoDeclineSettings1Request
*/
func (a *RepositoryAPIService) DeleteAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string) ApiDeleteAutoDeclineSettings1Request {
	return ApiDeleteAutoDeclineSettings1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteAutoDeclineSettings1Execute(r ApiDeleteAutoDeclineSettings1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteAutoDeclineSettings1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBranchRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiDeleteBranchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBranchExecute(r)
}

/*
DeleteBranch Delete branch

 Deletes a branch in the specified repository.


 If the branch does not exist, this operation will not raise an error. In other words after calling this resource
 and receiving a 204 response the branch provided in the request is guaranteed to not exist in the specified
 repository any more, regardless of its existence beforehand.


 The optional 'endPoint' parameter of the request may contain a commit ID that the provided ref name is
 expected to point to. Should the ref point to a different commit ID, a 400 response will be returned with
 appropriate error details.


 The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource. If
 branch permissions are set up in the repository, the authenticated user must also have access to the branch name
 that is to be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiDeleteBranchRequest
*/
func (a *RepositoryAPIService) DeleteBranch(ctx context.Context, projectKey string, repositorySlug string) ApiDeleteBranchRequest {
	return ApiDeleteBranchRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteBranchExecute(r ApiDeleteBranchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteBranch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCommentRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commentId string
	commitId string
	repositorySlug string
	version *string
}

// The expected version of the comment. This must match the server&#39;s version of the comment or the delete will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the delete. Look for the &#39;version&#39; attribute in the returned JSON structure.
func (r ApiDeleteCommentRequest) Version(version string) ApiDeleteCommentRequest {
	r.version = &version
	return r
}

func (r ApiDeleteCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCommentExecute(r)
}

/*
DeleteComment Delete a commit comment

Delete a commit comment. Anyone can delete their own comment. Only users with <strong>REPO_ADMIN</strong> and above may delete comments created by other users. Comments which have replies <i>may not be deleted</i>, regardless of the user's granted permissions.

The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commentId the comment
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiDeleteCommentRequest
*/
func (a *RepositoryAPIService) DeleteComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) ApiDeleteCommentRequest {
	return ApiDeleteCommentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commentId: commentId,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteCommentExecute(r ApiDeleteCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDefaultTask1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	taskId string
}

func (r ApiDeleteDefaultTask1Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDefaultTask1Execute(r)
}

/*
DeleteDefaultTask1 Delete a specific default task

Delete a specific default task for a repository.

The authenticated user must have **REPO_ADMIN** permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @param taskId The ID of the default task
 @return ApiDeleteDefaultTask1Request
*/
func (a *RepositoryAPIService) DeleteDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, taskId string) ApiDeleteDefaultTask1Request {
	return ApiDeleteDefaultTask1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteDefaultTask1Execute(r ApiDeleteDefaultTask1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteDefaultTask1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/default-tasks/latest/projects/{projectKey}/repos/{repositorySlug}/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRepositoryHookRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	hookKey string
	repositorySlug string
}

func (r ApiDeleteRepositoryHookRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryHookExecute(r)
}

/*
DeleteRepositoryHook Delete repository hook

Delete repository hook configuration for the supplied <strong>hookKey</strong> and <strong>repositorySlug</strong>

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param hookKey The hook key.
 @param repositorySlug The repository slug.
 @return ApiDeleteRepositoryHookRequest
*/
func (a *RepositoryAPIService) DeleteRepositoryHook(ctx context.Context, projectKey string, hookKey string, repositorySlug string) ApiDeleteRepositoryHookRequest {
	return ApiDeleteRepositoryHookRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		hookKey: hookKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteRepositoryHookExecute(r ApiDeleteRepositoryHookRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteRepositoryHook")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hookKey"+"}", url.PathEscape(parameterValueToString(r.hookKey, "hookKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRestriction1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	id string
	repositorySlug string
}

func (r ApiDeleteRestriction1Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRestriction1Execute(r)
}

/*
DeleteRestriction1 Delete a ref restriction

Deletes a restriction as specified by a restriction id.

The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param id The restriction id.
 @param repositorySlug The repository slug.
 @return ApiDeleteRestriction1Request
*/
func (a *RepositoryAPIService) DeleteRestriction1(ctx context.Context, projectKey string, id string, repositorySlug string) ApiDeleteRestriction1Request {
	return ApiDeleteRestriction1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		id: id,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteRestriction1Execute(r ApiDeleteRestriction1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteRestriction1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTagRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	name string
	repositorySlug string
}

func (r ApiDeleteTagRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTagExecute(r)
}

/*
DeleteTag Delete tag

Deletes a tag in the specified repository.

The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param name The name of the tag to be deleted.
 @param repositorySlug The repository slug.
 @return ApiDeleteTagRequest
*/
func (a *RepositoryAPIService) DeleteTag(ctx context.Context, projectKey string, name string, repositorySlug string) ApiDeleteTagRequest {
	return ApiDeleteTagRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		name: name,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteTagExecute(r ApiDeleteTagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteTag")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWebhook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	webhookId string
	repositorySlug string
}

func (r ApiDeleteWebhook1Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWebhook1Execute(r)
}

/*
DeleteWebhook1 Delete webhook

Delete a webhook for the repository specified via the URL. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param webhookId The ID of the webhook to be deleted.
 @param repositorySlug The repository slug.
 @return ApiDeleteWebhook1Request
*/
func (a *RepositoryAPIService) DeleteWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) ApiDeleteWebhook1Request {
	return ApiDeleteWebhook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		webhookId: webhookId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) DeleteWebhook1Execute(r ApiDeleteWebhook1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DeleteWebhook1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhookId"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableHook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	hookKey string
	repositorySlug string
}

func (r ApiDisableHook1Request) Execute() (*RestRepositoryHook, *http.Response, error) {
	return r.ApiService.DisableHook1Execute(r)
}

/*
DisableHook1 Disable repository hook

Disable a repository hook for this repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param hookKey The hook key.
 @param repositorySlug The repository slug.
 @return ApiDisableHook1Request
*/
func (a *RepositoryAPIService) DisableHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) ApiDisableHook1Request {
	return ApiDisableHook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		hookKey: hookKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRepositoryHook
func (a *RepositoryAPIService) DisableHook1Execute(r ApiDisableHook1Request) (*RestRepositoryHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRepositoryHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.DisableHook1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hookKey"+"}", url.PathEscape(parameterValueToString(r.hookKey, "hookKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditFileRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	branch *string
	content *string
	message *string
	sourceBranch *string
	sourceCommitId *string
}

// The branch on which the &lt;code&gt;path&lt;/code&gt; should be modified or created.
func (r ApiEditFileRequest) Branch(branch string) ApiEditFileRequest {
	r.branch = &branch
	return r
}

// The full content of the file at &lt;code&gt;path&lt;/code&gt;.
func (r ApiEditFileRequest) Content(content string) ApiEditFileRequest {
	r.content = &content
	return r
}

// The message associated with this change, to be used as the commit message. Or null if the default message should be used.
func (r ApiEditFileRequest) Message(message string) ApiEditFileRequest {
	r.message = &message
	return r
}

// The starting point for &lt;code&gt;branch&lt;/code&gt;. If provided and different from &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt; will be created as a new branch, branching off from &lt;code&gt;sourceBranch&lt;/code&gt;.
func (r ApiEditFileRequest) SourceBranch(sourceBranch string) ApiEditFileRequest {
	r.sourceBranch = &sourceBranch
	return r
}

// The commit ID of the file before it was edited, used to identify if content has changed. Or null if this is a new file
func (r ApiEditFileRequest) SourceCommitId(sourceCommitId string) ApiEditFileRequest {
	r.sourceCommitId = &sourceCommitId
	return r
}

func (r ApiEditFileRequest) Execute() (*RestCommit, *http.Response, error) {
	return r.ApiService.EditFileExecute(r)
}

/*
EditFile Edit file

Update the content of path, on the given repository and branch. 

This resource accepts PUT multipart form data, containing the file in a form-field named content. 

An example <a href="http://curl.haxx.se/">curl</a> request to update 'README.md' would be:

```curl -X PUT -u username:password -F content=@README.md  -F 'message=Updated using file-edit REST API' -F branch=master -F  sourceCommitId=5636641a50b  http://example.com/rest/api/latest/projects/PROJECT_1/repos/repo_1/browse/README.md ```

- branch:  the branch on which the path should be modified or created
- content: the full content of the file at path 
- message: the message associated with this change, to be used as the commit message. Or null if the default message should be used.
- sourceCommitId: the commit ID of the file before it was edited, used to identify if content has changed. Or null if this is a new file


The file can be updated or created on a new branch. In this case, the sourceBranch parameter should be provided to identify the starting point for the new branch and the branch parameter identifies the branch to create the new commit on.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The path of the file that is to be modified or created
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiEditFileRequest
*/
func (a *RepositoryAPIService) EditFile(ctx context.Context, path string, projectKey string, repositorySlug string) ApiEditFileRequest {
	return ApiEditFileRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestCommit
func (a *RepositoryAPIService) EditFileExecute(r ApiEditFileRequest) (*RestCommit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestCommit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.EditFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.branch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "branch", r.branch, "", "")
	}
	if r.content != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "", "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "", "")
	}
	if r.sourceBranch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sourceBranch", r.sourceBranch, "", "")
	}
	if r.sourceCommitId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sourceCommitId", r.sourceCommitId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnableHook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	hookKey string
	repositorySlug string
	contentLength *string
}

// The content length.
func (r ApiEnableHook1Request) ContentLength(contentLength string) ApiEnableHook1Request {
	r.contentLength = &contentLength
	return r
}

func (r ApiEnableHook1Request) Execute() (*RestRepositoryHook, *http.Response, error) {
	return r.ApiService.EnableHook1Execute(r)
}

/*
EnableHook1 Enable repository hook

Enable a repository hook for this repository and optionally apply new configuration. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource. 

A JSON document may be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param hookKey The hook key.
 @param repositorySlug The repository slug.
 @return ApiEnableHook1Request
*/
func (a *RepositoryAPIService) EnableHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) ApiEnableHook1Request {
	return ApiEnableHook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		hookKey: hookKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRepositoryHook
func (a *RepositoryAPIService) EnableHook1Execute(r ApiEnableHook1Request) (*RestRepositoryHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRepositoryHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.EnableHook1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hookKey"+"}", url.PathEscape(parameterValueToString(r.hookKey, "hookKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentLength != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Length", r.contentLength, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindBranchesRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	filterText *string
	start *float32
	limit *float32
}

// (optional) Partial match for a ref ID to filter minimal refs for
func (r ApiFindBranchesRequest) FilterText(filterText string) ApiFindBranchesRequest {
	r.filterText = &filterText
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiFindBranchesRequest) Start(start float32) ApiFindBranchesRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiFindBranchesRequest) Limit(limit float32) ApiFindBranchesRequest {
	r.limit = &limit
	return r
}

func (r ApiFindBranchesRequest) Execute() (*FindByCommit200Response, *http.Response, error) {
	return r.ApiService.FindBranchesExecute(r)
}

/*
FindBranches Get branches with ref change activities for repository

Retrieve a page of branches with ref change activities for a specific repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiFindBranchesRequest
*/
func (a *RepositoryAPIService) FindBranches(ctx context.Context, projectKey string, repositorySlug string) ApiFindBranchesRequest {
	return ApiFindBranchesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return FindByCommit200Response
func (a *RepositoryAPIService) FindBranchesExecute(r ApiFindBranchesRequest) (*FindByCommit200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindByCommit200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.FindBranches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterText", r.filterText, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindByCommitRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
	start *float32
	limit *float32
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiFindByCommitRequest) Start(start float32) ApiFindByCommitRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiFindByCommitRequest) Limit(limit float32) ApiFindByCommitRequest {
	r.limit = &limit
	return r
}

func (r ApiFindByCommitRequest) Execute() (*FindByCommit200Response, *http.Response, error) {
	return r.ApiService.FindByCommitExecute(r)
}

/*
FindByCommit Get branch

Gets the branch information associated with a single commit from a given repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commitId
 @param repositorySlug The repository slug.
 @return ApiFindByCommitRequest
*/
func (a *RepositoryAPIService) FindByCommit(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiFindByCommitRequest {
	return ApiFindByCommitRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return FindByCommit200Response
func (a *RepositoryAPIService) FindByCommitExecute(r ApiFindByCommitRequest) (*FindByCommit200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindByCommit200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.FindByCommit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches/info/{commitId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.commitId) > 40 {
		return localVarReturnValue, nil, reportError("commitId must have less than 40 elements")
	}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindWebhooks1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	event *string
	statistics *bool
}

// List of &lt;code&gt;com.atlassian.webhooks.WebhookEvent&lt;/code&gt; IDs to filter for
func (r ApiFindWebhooks1Request) Event(event string) ApiFindWebhooks1Request {
	r.event = &event
	return r
}

// &lt;code&gt;true&lt;/code&gt; if statistics should be provided for all found webhooks
func (r ApiFindWebhooks1Request) Statistics(statistics bool) ApiFindWebhooks1Request {
	r.statistics = &statistics
	return r
}

func (r ApiFindWebhooks1Request) Execute() (*http.Response, error) {
	return r.ApiService.FindWebhooks1Execute(r)
}

/*
FindWebhooks1 Find webhooks

Find webhooks in this repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiFindWebhooks1Request
*/
func (a *RepositoryAPIService) FindWebhooks1(ctx context.Context, projectKey string, repositorySlug string) ApiFindWebhooks1Request {
	return ApiFindWebhooks1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) FindWebhooks1Execute(r ApiFindWebhooks1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.FindWebhooks1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	if r.statistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statistics", r.statistics, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGet5Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiGet5Request) Execute() (*RestAutoMergeRestrictedSettings, *http.Response, error) {
	return r.ApiService.Get5Execute(r)
}

/*
Get5 Get pull request auto-merge settings

Retrieves the pull request auto-merge settings for the supplied repository. Project settings will be returned if no explicit settings have been set for the repository. In the case that there are no project settings, the default settings will be returned. If the repository's project has restricted its auto-merge settings, then the settings of the project will be returned.

The authenticated user must have <strong>REPO_READ</strong> permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiGet5Request
*/
func (a *RepositoryAPIService) Get5(ctx context.Context, projectKey string, repositorySlug string) ApiGet5Request {
	return ApiGet5Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestAutoMergeRestrictedSettings
func (a *RepositoryAPIService) Get5Execute(r ApiGet5Request) (*RestAutoMergeRestrictedSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestAutoMergeRestrictedSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Get5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllLabelsForRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiGetAllLabelsForRepositoryRequest) Execute() (*RestLabel, *http.Response, error) {
	return r.ApiService.GetAllLabelsForRepositoryExecute(r)
}

/*
GetAllLabelsForRepository Get repository labels

Get all labels applied to the given repository. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetAllLabelsForRepositoryRequest
*/
func (a *RepositoryAPIService) GetAllLabelsForRepository(ctx context.Context, projectKey string, repositorySlug string) ApiGetAllLabelsForRepositoryRequest {
	return ApiGetAllLabelsForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestLabel
func (a *RepositoryAPIService) GetAllLabelsForRepositoryExecute(r ApiGetAllLabelsForRepositoryRequest) (*RestLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetAllLabelsForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArchiveRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	path *string
	filename *string
	at *string
	prefix *string
	format *string
}

// Paths to include in the streamed archive; may be repeated to include multiple paths
func (r ApiGetArchiveRequest) Path(path string) ApiGetArchiveRequest {
	r.path = &path
	return r
}

// A filename to include the \&quot;Content-Disposition\&quot; header
func (r ApiGetArchiveRequest) Filename(filename string) ApiGetArchiveRequest {
	r.filename = &filename
	return r
}

// The commit to stream an archive of; if not supplied, an archive of the default branch is streamed
func (r ApiGetArchiveRequest) At(at string) ApiGetArchiveRequest {
	r.at = &at
	return r
}

// A prefix to apply to all entries in the streamed archive; if the supplied prefix does not end with a trailing /, one will be added automatically
func (r ApiGetArchiveRequest) Prefix(prefix string) ApiGetArchiveRequest {
	r.prefix = &prefix
	return r
}

// The format to stream the archive in; must be one of: zip, tar, tar.gz or tgz
func (r ApiGetArchiveRequest) Format(format string) ApiGetArchiveRequest {
	r.format = &format
	return r
}

func (r ApiGetArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetArchiveExecute(r)
}

/*
GetArchive Stream archive of repository

Streams an archive of the repository's contents at the requested commit. If no `at=` commit is requested, an archive of the default branch is streamed.

The <code>filename=</code> query parameter may be used to specify the exact filename to include in the "Content-Disposition" header. If an explicit filename is not provided, one will be automatically generated based on what is being archived. Its format depends on the at= value: 

- No <code>at=</code> commit:     &lt;slug&gt;-&lt;default-branch-name&gt;@&lt;commit&gt;.&lt;format&gt;;     e.g. example-master@43c2f8a0fe8.zip
- <code>at=</code>sha: &lt;slug&gt;-&lt;at&gt;.&lt;format&gt;; e.g.     example-09bcbb00100cfbb5310fb6834a1d5ce6cac253e9.tar.gz
- <code>at=</code>branchOrTag: &lt;slug&gt;-&lt;branchOrTag&gt;@&lt;commit&gt;.&lt;format&gt;;     e.g. example-feature@bbb225f16e1.tar 

    - If the branch or tag is qualified (e.g. refs/heads/master, the short name         (master) will be included in the filename
    - If the branch or tag's <i>short name</i> includes slashes (e.g. release/4.6),         they will be converted to hyphens in the filename (release-4.5)




Archives may be requested in the following formats by adding the <code>format=</code> query parameter: 

- zip: A zip file using standard compression (Default)
- tar: An uncompressed tarball
- tar.gz or tgz: A GZip-compressed tarball


The contents of the archive may be filtered by using the <code>path=</code> query parameter to specify paths to include. <code>path=</code> may be specified multiple times to include multiple paths. 

The <code>prefix=</code> query parameter may be used to define a directory (or multiple directories) where the archive's contents should be placed. If the prefix does not end with /, one will be added automatically. The prefix is <i>always</i> treated as a directory; it is not possible to use it to prepend characters to the entries in the archive. 

Archives of public repositories may be streamed by any authenticated or anonymous user. Streaming archives for non-public repositories requires an <i>authenticated user</i> with at least <b>REPO_READ</b> permission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetArchiveRequest
*/
func (a *RepositoryAPIService) GetArchive(ctx context.Context, projectKey string, repositorySlug string) ApiGetArchiveRequest {
	return ApiGetArchiveRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) GetArchiveExecute(r ApiGetArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/x-tar", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAttachmentRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	attachmentId string
	repositorySlug string
	userAgent *string
	range_ *string
}

func (r ApiGetAttachmentRequest) UserAgent(userAgent string) ApiGetAttachmentRequest {
	r.userAgent = &userAgent
	return r
}

func (r ApiGetAttachmentRequest) Range_(range_ string) ApiGetAttachmentRequest {
	r.range_ = &range_
	return r
}

func (r ApiGetAttachmentRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAttachmentExecute(r)
}

/*
GetAttachment Get an attachment

Retrieve the attachment.

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment.

Range requests (see IETF RFC7233) are supported. However only a single range issupported. If multiple ranges are passed the ranges will be ignored and the entire content will be returned in the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param attachmentId the attachment ID
 @param repositorySlug The repository slug
 @return ApiGetAttachmentRequest
*/
func (a *RepositoryAPIService) GetAttachment(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) ApiGetAttachmentRequest {
	return ApiGetAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		attachmentId: attachmentId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) GetAttachmentExecute(r ApiGetAttachmentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetAttachment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAttachmentMetadataRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	attachmentId string
	repositorySlug string
}

func (r ApiGetAttachmentMetadataRequest) Execute() (*RestAttachmentMetadata, *http.Response, error) {
	return r.ApiService.GetAttachmentMetadataExecute(r)
}

/*
GetAttachmentMetadata Get attachment metadata

Retrieve the attachment metadata.

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment that has the attachment metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param attachmentId the attachment ID
 @param repositorySlug The repository slug
 @return ApiGetAttachmentMetadataRequest
*/
func (a *RepositoryAPIService) GetAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) ApiGetAttachmentMetadataRequest {
	return ApiGetAttachmentMetadataRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		attachmentId: attachmentId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestAttachmentMetadata
func (a *RepositoryAPIService) GetAttachmentMetadataExecute(r ApiGetAttachmentMetadataRequest) (*RestAttachmentMetadata, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestAttachmentMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetAttachmentMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutoDeclineSettings1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiGetAutoDeclineSettings1Request) Execute() (*RestAutoDeclineSettings, *http.Response, error) {
	return r.ApiService.GetAutoDeclineSettings1Execute(r)
}

/*
GetAutoDeclineSettings1 Get auto decline settings

Retrieves the auto decline settings for the supplied repository. Project settings will be returned if no explicit settings have been set for the repository. In the case that there are no project settings, the default settings will be returned.

The authenticated user must have <strong>REPO_READ</strong> permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiGetAutoDeclineSettings1Request
*/
func (a *RepositoryAPIService) GetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string) ApiGetAutoDeclineSettings1Request {
	return ApiGetAutoDeclineSettings1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestAutoDeclineSettings
func (a *RepositoryAPIService) GetAutoDeclineSettings1Execute(r ApiGetAutoDeclineSettings1Request) (*RestAutoDeclineSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestAutoDeclineSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetAutoDeclineSettings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchesRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	boostMatches *bool
	context *string
	orderBy *string
	details *bool
	filterText *string
	base *string
	start *float32
	limit *float32
}

// Controls whether exact and prefix matches will be boosted to the top
func (r ApiGetBranchesRequest) BoostMatches(boostMatches bool) ApiGetBranchesRequest {
	r.boostMatches = &boostMatches
	return r
}

func (r ApiGetBranchesRequest) Context(context string) ApiGetBranchesRequest {
	r.context = &context
	return r
}

// Ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated)
func (r ApiGetBranchesRequest) OrderBy(orderBy string) ApiGetBranchesRequest {
	r.orderBy = &orderBy
	return r
}

// Whether to retrieve plugin-provided metadata about each branch
func (r ApiGetBranchesRequest) Details(details bool) ApiGetBranchesRequest {
	r.details = &details
	return r
}

// The text to match on
func (r ApiGetBranchesRequest) FilterText(filterText string) ApiGetBranchesRequest {
	r.filterText = &filterText
	return r
}

// Base branch or tag to compare each branch to (for the metadata providers that uses that information
func (r ApiGetBranchesRequest) Base(base string) ApiGetBranchesRequest {
	r.base = &base
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetBranchesRequest) Start(start float32) ApiGetBranchesRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetBranchesRequest) Limit(limit float32) ApiGetBranchesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBranchesRequest) Execute() (*GetBranches200Response, *http.Response, error) {
	return r.ApiService.GetBranchesExecute(r)
}

/*
GetBranches Find branches

Retrieve the branches matching the supplied <strong>filterText</strong> param. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetBranchesRequest
*/
func (a *RepositoryAPIService) GetBranches(ctx context.Context, projectKey string, repositorySlug string) ApiGetBranchesRequest {
	return ApiGetBranchesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetBranches200Response
func (a *RepositoryAPIService) GetBranchesExecute(r ApiGetBranchesRequest) (*GetBranches200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBranches200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetBranches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.boostMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "boostMatches", r.boostMatches, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	if r.filterText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterText", r.filterText, "form", "")
	}
	if r.base != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base", r.base, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChangesRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
	withComments *string
	since *string
	start *float32
	limit *float32
}

// &lt;code&gt;true&lt;/code&gt; to apply comment counts in the changes (the default); otherwise, &lt;code&gt;false&lt;/code&gt; to stream changes without comment counts
func (r ApiGetChangesRequest) WithComments(withComments string) ApiGetChangesRequest {
	r.withComments = &withComments
	return r
}

// The commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes. If not specified the commit&#39;s first parent is assumed (if one exists)
func (r ApiGetChangesRequest) Since(since string) ApiGetChangesRequest {
	r.since = &since
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetChangesRequest) Start(start float32) ApiGetChangesRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetChangesRequest) Limit(limit float32) ApiGetChangesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetChangesRequest) Execute() (*GetChanges1200Response, *http.Response, error) {
	return r.ApiService.GetChangesExecute(r)
}

/*
GetChanges Get changes in commit

Retrieve a page of changes made in a specified commit. 

 <strong>Note:</strong> The implementation will apply a hard cap (<code>page.max.changes</code>) and it is not possible to request subsequent content when that cap is exceeded. 

 The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId The commit to retrieve changes for
 @param repositorySlug The repository slug
 @return ApiGetChangesRequest
*/
func (a *RepositoryAPIService) GetChanges(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGetChangesRequest {
	return ApiGetChangesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetChanges1200Response
func (a *RepositoryAPIService) GetChangesExecute(r ApiGetChangesRequest) (*GetChanges1200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChanges1200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withComments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withComments", r.withComments, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChanges1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	until *string
	since *string
	start *float32
	limit *float32
}

// The commit to retrieve changes for
func (r ApiGetChanges1Request) Until(until string) ApiGetChanges1Request {
	r.until = &until
	return r
}

// The commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes. If not specified the commit&#39;s first parent is assumed (if one exists)
func (r ApiGetChanges1Request) Since(since string) ApiGetChanges1Request {
	r.since = &since
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetChanges1Request) Start(start float32) ApiGetChanges1Request {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetChanges1Request) Limit(limit float32) ApiGetChanges1Request {
	r.limit = &limit
	return r
}

func (r ApiGetChanges1Request) Execute() (*GetChanges1200Response, *http.Response, error) {
	return r.ApiService.GetChanges1Execute(r)
}

/*
GetChanges1 Get changes made in commit

Retrieve a page of changes made in a specified commit. 

<strong>Note:</strong> The implementation will apply a hard cap ({@code page.max.changes}) and it is not possible to request subsequent content when that cap is exceeded. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetChanges1Request
*/
func (a *RepositoryAPIService) GetChanges1(ctx context.Context, projectKey string, repositorySlug string) ApiGetChanges1Request {
	return ApiGetChanges1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetChanges1200Response
func (a *RepositoryAPIService) GetChanges1Execute(r ApiGetChanges1Request) (*GetChanges1200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChanges1200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetChanges1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commentId string
	commitId string
	repositorySlug string
}

func (r ApiGetCommentRequest) Execute() (*RestComment, *http.Response, error) {
	return r.ApiService.GetCommentExecute(r)
}

/*
GetComment Get a commit comment

Retrieves a commit discussion comment.

The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commentId The ID of the comment to retrieve
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiGetCommentRequest
*/
func (a *RepositoryAPIService) GetComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) ApiGetCommentRequest {
	return ApiGetCommentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commentId: commentId,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestComment
func (a *RepositoryAPIService) GetCommentExecute(r ApiGetCommentRequest) (*RestComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentsRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
	path *string
	since *string
	start *float32
	limit *float32
}

// The path to the file on which comments were made
func (r ApiGetCommentsRequest) Path(path string) ApiGetCommentsRequest {
	r.path = &path
	return r
}

// For a merge commit, a parent can be provided to specify which diff the comments are on. For a commit range, a sinceId can be provided to specify where the comments are anchored from.
func (r ApiGetCommentsRequest) Since(since string) ApiGetCommentsRequest {
	r.since = &since
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetCommentsRequest) Start(start float32) ApiGetCommentsRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetCommentsRequest) Limit(limit float32) ApiGetCommentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCommentsRequest) Execute() (*GetComments200Response, *http.Response, error) {
	return r.ApiService.GetCommentsExecute(r)
}

/*
GetComments Search for commit comments

Retrieves the commit discussion comments that match the specified search criteria.

It is possible to retrieve commit discussion comments that are anchored to a range of commits by providing the sinceId that the comments anchored from.

The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiGetCommentsRequest
*/
func (a *RepositoryAPIService) GetComments(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGetCommentsRequest {
	return ApiGetCommentsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetComments200Response
func (a *RepositoryAPIService) GetCommentsExecute(r ApiGetCommentsRequest) (*GetComments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetComments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommitRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
	path *string
}

// An optional path to filter the commit by. If supplied the details returned &lt;i&gt;may not&lt;/i&gt; be for the specified commit. Instead, starting from the specified commit, they will be the details for the first commit affecting the specified path.
func (r ApiGetCommitRequest) Path(path string) ApiGetCommitRequest {
	r.path = &path
	return r
}

func (r ApiGetCommitRequest) Execute() (*RestCommit, *http.Response, error) {
	return r.ApiService.GetCommitExecute(r)
}

/*
GetCommit Get commit by ID

Retrieve a single commit <i>identified by its ID</i>. In general, that ID is a SHA1. <u>From 2.11, ref names like "refs/heads/master" are no longer accepted by this resource.</u>

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId The commit ID to retrieve
 @param repositorySlug The repository slug
 @return ApiGetCommitRequest
*/
func (a *RepositoryAPIService) GetCommit(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGetCommitRequest {
	return ApiGetCommitRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestCommit
func (a *RepositoryAPIService) GetCommitExecute(r ApiGetCommitRequest) (*RestCommit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestCommit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetCommit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommitsRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	avatarScheme *string
	path *string
	withCounts *string
	followRenames *string
	until *string
	avatarSize *string
	since *string
	merges *string
	ignoreMissing *string
	start *float32
	limit *float32
}

// The desired scheme for the avatar URL. If the parameter is not present URLs will use the same scheme as this request
func (r ApiGetCommitsRequest) AvatarScheme(avatarScheme string) ApiGetCommitsRequest {
	r.avatarScheme = &avatarScheme
	return r
}

// An optional path to filter commits by
func (r ApiGetCommitsRequest) Path(path string) ApiGetCommitsRequest {
	r.path = &path
	return r
}

// Optionally include the total number of commits and total number of unique authors
func (r ApiGetCommitsRequest) WithCounts(withCounts string) ApiGetCommitsRequest {
	r.withCounts = &withCounts
	return r
}

// If &lt;code&gt;true&lt;/code&gt;, the commit history of the specified file will be followed past renames. Only valid for a path to a single file.
func (r ApiGetCommitsRequest) FollowRenames(followRenames string) ApiGetCommitsRequest {
	r.followRenames = &followRenames
	return r
}

// The commit ID (SHA1) or ref (inclusively) to retrieve commits before
func (r ApiGetCommitsRequest) Until(until string) ApiGetCommitsRequest {
	r.until = &until
	return r
}

// If present the service adds avatar URLs for commit authors. Should be an integer specifying the desired size in pixels. If the parameter is not present, avatar URLs will not be set
func (r ApiGetCommitsRequest) AvatarSize(avatarSize string) ApiGetCommitsRequest {
	r.avatarSize = &avatarSize
	return r
}

// The commit ID or ref (exclusively) to retrieve commits after
func (r ApiGetCommitsRequest) Since(since string) ApiGetCommitsRequest {
	r.since = &since
	return r
}

// If present, controls how merge commits should be filtered. Can be either &lt;code&gt;exclude&lt;/code&gt;, to exclude merge commits, &lt;code&gt;include&lt;/code&gt;, to include both merge commits and non-merge commits or &lt;code&gt;only&lt;/code&gt;, to only return merge commits.
func (r ApiGetCommitsRequest) Merges(merges string) ApiGetCommitsRequest {
	r.merges = &merges
	return r
}

// &lt;code&gt;true&lt;/code&gt; to ignore missing commits, &lt;code&gt;false&lt;/code&gt; otherwise
func (r ApiGetCommitsRequest) IgnoreMissing(ignoreMissing string) ApiGetCommitsRequest {
	r.ignoreMissing = &ignoreMissing
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetCommitsRequest) Start(start float32) ApiGetCommitsRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetCommitsRequest) Limit(limit float32) ApiGetCommitsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCommitsRequest) Execute() (*GetCommits200Response, *http.Response, error) {
	return r.ApiService.GetCommitsExecute(r)
}

/*
GetCommits Get commits

Retrieve a page of commits from a given starting commit or "between" two commits. If no explicit commit is specified, the tip of the repository's default branch is assumed. commits may be identified by branch or tag name or by ID. A path may be supplied to restrict the returned commits to only those which affect that path. 

The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiGetCommitsRequest
*/
func (a *RepositoryAPIService) GetCommits(ctx context.Context, projectKey string, repositorySlug string) ApiGetCommitsRequest {
	return ApiGetCommitsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetCommits200Response
func (a *RepositoryAPIService) GetCommitsExecute(r ApiGetCommitsRequest) (*GetCommits200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCommits200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetCommits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.avatarScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avatarScheme", r.avatarScheme, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.withCounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCounts", r.withCounts, "form", "")
	}
	if r.followRenames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followRenames", r.followRenames, "form", "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "form", "")
	}
	if r.avatarSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avatarSize", r.avatarSize, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	if r.merges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "merges", r.merges, "form", "")
	}
	if r.ignoreMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreMissing", r.ignoreMissing, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigurations1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	start *float32
	limit *float32
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetConfigurations1Request) Start(start float32) ApiGetConfigurations1Request {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetConfigurations1Request) Limit(limit float32) ApiGetConfigurations1Request {
	r.limit = &limit
	return r
}

func (r ApiGetConfigurations1Request) Execute() (*GetConfigurations200Response, *http.Response, error) {
	return r.ApiService.GetConfigurations1Execute(r)
}

/*
GetConfigurations1 Get hook scripts

Return a page of hook scripts configured for the specified repository. 

This endpoint requires **REPO_ADMIN** permission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetConfigurations1Request
*/
func (a *RepositoryAPIService) GetConfigurations1(ctx context.Context, projectKey string, repositorySlug string) ApiGetConfigurations1Request {
	return ApiGetConfigurations1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetConfigurations200Response
func (a *RepositoryAPIService) GetConfigurations1Execute(r ApiGetConfigurations1Request) (*GetConfigurations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetConfigurations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetConfigurations1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContentRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	noContent *string
	at *string
	size *string
	blame *string
	type_ *string
}

// If blame&amp;amp;noContent only the blame is retrieved instead of the contents
func (r ApiGetContentRequest) NoContent(noContent string) ApiGetContentRequest {
	r.noContent = &noContent
	return r
}

// The commit ID or ref to retrieve the content for
func (r ApiGetContentRequest) At(at string) ApiGetContentRequest {
	r.at = &at
	return r
}

// If true only the size will be returned for the file path instead of the contents
func (r ApiGetContentRequest) Size(size string) ApiGetContentRequest {
	r.size = &size
	return r
}

// If present and not equal to &#39;false&#39;, the blame will be returned for the file as well
func (r ApiGetContentRequest) Blame(blame string) ApiGetContentRequest {
	r.blame = &blame
	return r
}

// If true only the type will be returned for the file path instead of the contents
func (r ApiGetContentRequest) Type_(type_ string) ApiGetContentRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetContentRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetContentExecute(r)
}

/*
GetContent Get file content at revision

Retrieve a page of content for a file path at a specified revision. 

Responses from this endpoint vary widely depending on the query parameters. The example JSON is for a request that does not use size, type, blame or noContent. 

1. size will return a response like {"size":10000}
2. type will return a response like {"type":"FILE"}, where possible values are    "DIRECTORY", "FILE" and "SUBMODULE"
3. blame <i>without</i> noContent will include blame for the lines of    content returned on the page
4. blame <i>with</i> noContent will omit file contents and only return    blame for the requested lines
5. noContent without blame is ignored and does nothing


The various parameters are "processed" in the above order. That means ?size=true&amp;type=truewill return a size response, not a type one; the type parameter will be ignored. 

The blame and noContent query parameters are handled differently from size and type. For blame and noContent, the <i>presence</i> of the parameter implies "true" if no value is specified; size and and type both require an explicit=true or they're treated as "false". 

- ?blame is the same as ?blame=true
- ?blame&amp;noContent is the same as ?blame=true&amp;noContent=true
- ?size is the same as ?size=false
- ?type is the same as ?type=false


The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetContentRequest
*/
func (a *RepositoryAPIService) GetContent(ctx context.Context, projectKey string, repositorySlug string) ApiGetContentRequest {
	return ApiGetContentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) GetContentExecute(r ApiGetContentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetContent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.noContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noContent", r.noContent, "form", "")
	}
	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.blame != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blame", r.blame, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetContent1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	noContent *string
	at *string
	size *string
	blame *string
	type_ *string
}

// If blame&amp;amp;noContent only the blame is retrieved instead of the contents
func (r ApiGetContent1Request) NoContent(noContent string) ApiGetContent1Request {
	r.noContent = &noContent
	return r
}

// The commit ID or ref to retrieve the content for
func (r ApiGetContent1Request) At(at string) ApiGetContent1Request {
	r.at = &at
	return r
}

// If true only the size will be returned for the file path instead of the contents
func (r ApiGetContent1Request) Size(size string) ApiGetContent1Request {
	r.size = &size
	return r
}

// If present and not equal to &#39;false&#39;, the blame will be returned for the file as well
func (r ApiGetContent1Request) Blame(blame string) ApiGetContent1Request {
	r.blame = &blame
	return r
}

// If true only the type will be returned for the file path instead of the contents
func (r ApiGetContent1Request) Type_(type_ string) ApiGetContent1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetContent1Request) Execute() (*http.Response, error) {
	return r.ApiService.GetContent1Execute(r)
}

/*
GetContent1 Get file content

Retrieve a page of content for a file path at a specified revision. 

Responses from this endpoint vary widely depending on the query parameters. The example JSON is for a request that does not use size, type, blame or noContent. 

1. size will return a response like {"size":10000}
2. type will return a response like {"type":"FILE"}, where possible values are    "DIRECTORY", "FILE" and "SUBMODULE"
3. blame <i>without</i> noContent will include blame for the lines of    content returned on the page
4. blame <i>with</i> noContent will omit file contents and only return    blame for the requested lines
5. noContent without blame is ignored and does nothing


The various parameters are "processed" in the above order. That means ?size=true&amp;type=truewill return a size response, not a type one; the type parameter will be ignored. 

The blame and noContent query parameters are handled differently from size and type. For blame and noContent, the <i>presence</i> of the parameter implies "true" if no value is specified; size and and type both require an explicit=true or they're treated as "false". 

- ?blame is the same as ?blame=true
- ?blame&amp;noContent is the same as ?blame=true&amp;noContent=true
- ?size is the same as ?size=false
- ?type is the same as ?type=false


The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The file path to retrieve content from
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetContent1Request
*/
func (a *RepositoryAPIService) GetContent1(ctx context.Context, path string, projectKey string, repositorySlug string) ApiGetContent1Request {
	return ApiGetContent1Request{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) GetContent1Execute(r ApiGetContent1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetContent1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.noContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noContent", r.noContent, "form", "")
	}
	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.blame != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blame", r.blame, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDefaultBranch1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiGetDefaultBranch1Request) Execute() (*RestBranch, *http.Response, error) {
	return r.ApiService.GetDefaultBranch1Execute(r)
}

/*
GetDefaultBranch1 Get default branch

Retrieves the repository's default branch, if it has been created. If the repository is empty, 204 No Content will be returned. For non-empty repositories, if the configured default branch has not yet been created a 404 Not Found will be returned. 

This URL is deprecated. Callers should use <code>GET /projects/{key}/repos/{slug}/default-branch</code> instead, which allows retrieving the <i>configured</i> default branch even if the ref has not been created yet. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetDefaultBranch1Request

Deprecated
*/
func (a *RepositoryAPIService) GetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string) ApiGetDefaultBranch1Request {
	return ApiGetDefaultBranch1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestBranch
// Deprecated
func (a *RepositoryAPIService) GetDefaultBranch1Execute(r ApiGetDefaultBranch1Request) (*RestBranch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestBranch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetDefaultBranch1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultTasks1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	markup *string
	start *float32
	limit *float32
}

// If present or &#x60;\&quot;true\&quot;&#x60;, includes a markup-rendered description
func (r ApiGetDefaultTasks1Request) Markup(markup string) ApiGetDefaultTasks1Request {
	r.markup = &markup
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetDefaultTasks1Request) Start(start float32) ApiGetDefaultTasks1Request {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetDefaultTasks1Request) Limit(limit float32) ApiGetDefaultTasks1Request {
	r.limit = &limit
	return r
}

func (r ApiGetDefaultTasks1Request) Execute() (*GetDefaultTasks1200Response, *http.Response, error) {
	return r.ApiService.GetDefaultTasks1Execute(r)
}

/*
GetDefaultTasks1 Get a page of default tasks

Retrieves the default tasks for the supplied repository.

The authenticated user must have **REPO_VIEW** permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetDefaultTasks1Request
*/
func (a *RepositoryAPIService) GetDefaultTasks1(ctx context.Context, projectKey string, repositorySlug string) ApiGetDefaultTasks1Request {
	return ApiGetDefaultTasks1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetDefaultTasks1200Response
func (a *RepositoryAPIService) GetDefaultTasks1Execute(r ApiGetDefaultTasks1Request) (*GetDefaultTasks1200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDefaultTasks1200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetDefaultTasks1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/default-tasks/latest/projects/{projectKey}/repos/{repositorySlug}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.markup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markup", r.markup, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDiffStatsSummaryRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	commitId string
	repositorySlug string
	srcPath *string
	autoSrcPath *string
	whitespace *string
	since *string
}

// The source path for the file, if it was copied, moved or renamed
func (r ApiGetDiffStatsSummaryRequest) SrcPath(srcPath string) ApiGetDiffStatsSummaryRequest {
	r.srcPath = &srcPath
	return r
}

// &lt;code&gt;true&lt;/code&gt; to automatically try to find the source path when it&#39;s not provided, &lt;code&gt;false&lt;/code&gt; otherwise. Requires the path to be provided.
func (r ApiGetDiffStatsSummaryRequest) AutoSrcPath(autoSrcPath string) ApiGetDiffStatsSummaryRequest {
	r.autoSrcPath = &autoSrcPath
	return r
}

// Optional whitespace flag which can be set to ignore-all
func (r ApiGetDiffStatsSummaryRequest) Whitespace(whitespace string) ApiGetDiffStatsSummaryRequest {
	r.whitespace = &whitespace
	return r
}

// The base revision to diff from. If omitted the parent revision of the commit ID is used
func (r ApiGetDiffStatsSummaryRequest) Since(since string) ApiGetDiffStatsSummaryRequest {
	r.since = &since
	return r
}

func (r ApiGetDiffStatsSummaryRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetDiffStatsSummaryExecute(r)
}

/*
GetDiffStatsSummary Get diff stats summary between revisions

Retrieve the diff stats summary for a commit.

The stats summary include the total number of modified files, added lines, and deleted lines. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The path to the file which should be diffed (optional)
 @param projectKey The project key
 @param commitId The commit ID to diff to.
 @param repositorySlug The repository slug
 @return ApiGetDiffStatsSummaryRequest
*/
func (a *RepositoryAPIService) GetDiffStatsSummary(ctx context.Context, path string, projectKey string, commitId string, repositorySlug string) ApiGetDiffStatsSummaryRequest {
	return ApiGetDiffStatsSummaryRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return interface{}
func (a *RepositoryAPIService) GetDiffStatsSummaryExecute(r ApiGetDiffStatsSummaryRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetDiffStatsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff-stats-summary/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.srcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "srcPath", r.srcPath, "form", "")
	}
	if r.autoSrcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoSrcPath", r.autoSrcPath, "form", "")
	}
	if r.whitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whitespace", r.whitespace, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDiffStatsSummary1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	fromRepo *string
	srcPath *string
	from *string
	to *string
	whitespace *string
}

// an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt;
func (r ApiGetDiffStatsSummary1Request) FromRepo(fromRepo string) ApiGetDiffStatsSummary1Request {
	r.fromRepo = &fromRepo
	return r
}

// source path
func (r ApiGetDiffStatsSummary1Request) SrcPath(srcPath string) ApiGetDiffStatsSummary1Request {
	r.srcPath = &srcPath
	return r
}

// the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiGetDiffStatsSummary1Request) From(from string) ApiGetDiffStatsSummary1Request {
	r.from = &from
	return r
}

// the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiGetDiffStatsSummary1Request) To(to string) ApiGetDiffStatsSummary1Request {
	r.to = &to
	return r
}

// an optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt;
func (r ApiGetDiffStatsSummary1Request) Whitespace(whitespace string) ApiGetDiffStatsSummary1Request {
	r.whitespace = &whitespace
	return r
}

func (r ApiGetDiffStatsSummary1Request) Execute() (*RestDiff, *http.Response, error) {
	return r.ApiService.GetDiffStatsSummary1Execute(r)
}

/*
GetDiffStatsSummary1 Retrieve the diff stats summary between commits

Retrieve the diff stats summary of the changes available in the <code>from</code> commit but not in the <code> to</code> commit.

If either the <code> from</code> or <code> to</code> commit are not specified, they will be replaced by the default branch of their containing repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path the path to the file to diff (optional)
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetDiffStatsSummary1Request
*/
func (a *RepositoryAPIService) GetDiffStatsSummary1(ctx context.Context, path string, projectKey string, repositorySlug string) ApiGetDiffStatsSummary1Request {
	return ApiGetDiffStatsSummary1Request{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestDiff
func (a *RepositoryAPIService) GetDiffStatsSummary1Execute(r ApiGetDiffStatsSummary1Request) (*RestDiff, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDiff
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetDiffStatsSummary1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/diff-stats-summary{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromRepo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRepo", r.fromRepo, "form", "")
	}
	if r.srcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "srcPath", r.srcPath, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	if r.whitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whitespace", r.whitespace, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestInvocation1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	webhookId string
	repositorySlug string
	event *string
	outcome *string
}

// The string ID of a specific event to retrieve the last invocation for.
func (r ApiGetLatestInvocation1Request) Event(event string) ApiGetLatestInvocation1Request {
	r.event = &event
	return r
}

// The outcome to filter for. Can be SUCCESS, FAILURE, ERROR. None specified means that the all will be considered
func (r ApiGetLatestInvocation1Request) Outcome(outcome string) ApiGetLatestInvocation1Request {
	r.outcome = &outcome
	return r
}

func (r ApiGetLatestInvocation1Request) Execute() (*RestDetailedInvocation, *http.Response, error) {
	return r.ApiService.GetLatestInvocation1Execute(r)
}

/*
GetLatestInvocation1 Get last webhook invocation details

Get the latest invocations for a specific webhook. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param webhookId ID of the webhook
 @param repositorySlug The repository slug.
 @return ApiGetLatestInvocation1Request
*/
func (a *RepositoryAPIService) GetLatestInvocation1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) ApiGetLatestInvocation1Request {
	return ApiGetLatestInvocation1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		webhookId: webhookId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestDetailedInvocation
func (a *RepositoryAPIService) GetLatestInvocation1Execute(r ApiGetLatestInvocation1Request) (*RestDetailedInvocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDetailedInvocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetLatestInvocation1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhookId"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	if r.outcome != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outcome", r.outcome, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMergeBaseRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
	otherCommitId *string
}

// The other commit id to calculate the merge-base on
func (r ApiGetMergeBaseRequest) OtherCommitId(otherCommitId string) ApiGetMergeBaseRequest {
	r.otherCommitId = &otherCommitId
	return r
}

func (r ApiGetMergeBaseRequest) Execute() (*RestCommit, *http.Response, error) {
	return r.ApiService.GetMergeBaseExecute(r)
}

/*
GetMergeBase Get the common ancestor between two commits

Returns the best common ancestor between two commits.

If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiGetMergeBaseRequest
*/
func (a *RepositoryAPIService) GetMergeBase(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiGetMergeBaseRequest {
	return ApiGetMergeBaseRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestCommit
func (a *RepositoryAPIService) GetMergeBaseExecute(r ApiGetMergeBaseRequest) (*RestCommit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestCommit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetMergeBase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/merge-base"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.otherCommitId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "otherCommitId", r.otherCommitId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPullRequestSettings1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiGetPullRequestSettings1Request) Execute() (*RestRepositoryPullRequestSettings, *http.Response, error) {
	return r.ApiService.GetPullRequestSettings1Execute(r)
}

/*
GetPullRequestSettings1 Get pull request settings

Retrieve the pull request settings for the context repository. 

The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource. 

This resource will call all RestFragments that are registered with the key <strong>bitbucket.repository.settings.pullRequests</strong>. If any fragment fails validations by returning a non-empty Map of errors, then no fragments will execute. 

The property keys for the settings that are bundled with the application are 

- mergeConfig - the merge strategy configuration for pull requests
- requiredApprovers - (Deprecated, please use com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook instead) the number of approvals required on a pull request for it to be mergeable, or 0 if the merge check is disabled
- com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook - the merge check configuration for required approvers
- requiredAllApprovers - whether or not all approvers must approve a pull request for it to be mergeable
- requiredAllTasksComplete - whether or not all tasks on a pull request need to be completed for it to be mergeable
- requiredSuccessfulBuilds - (Deprecated, please use com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck instead) the number of successful builds on a pull request for it to be mergeable, or 0 if the merge check is disabled
- com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck - the merge check configuration for required builds




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetPullRequestSettings1Request
*/
func (a *RepositoryAPIService) GetPullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string) ApiGetPullRequestSettings1Request {
	return ApiGetPullRequestSettings1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRepositoryPullRequestSettings
func (a *RepositoryAPIService) GetPullRequestSettings1Execute(r ApiGetPullRequestSettings1Request) (*RestRepositoryPullRequestSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRepositoryPullRequestSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetPullRequestSettings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRefChangeActivityRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	ref *string
	start *float32
	limit *float32
}

// (optional) exact match for a ref ID to filter ref change activity for
func (r ApiGetRefChangeActivityRequest) Ref(ref string) ApiGetRefChangeActivityRequest {
	r.ref = &ref
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetRefChangeActivityRequest) Start(start float32) ApiGetRefChangeActivityRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetRefChangeActivityRequest) Limit(limit float32) ApiGetRefChangeActivityRequest {
	r.limit = &limit
	return r
}

func (r ApiGetRefChangeActivityRequest) Execute() (*GetRefChangeActivity200Response, *http.Response, error) {
	return r.ApiService.GetRefChangeActivityExecute(r)
}

/*
GetRefChangeActivity Get ref change activity

Retrieve a page of repository ref change activity. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetRefChangeActivityRequest
*/
func (a *RepositoryAPIService) GetRefChangeActivity(ctx context.Context, projectKey string, repositorySlug string) ApiGetRefChangeActivityRequest {
	return ApiGetRefChangeActivityRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetRefChangeActivity200Response
func (a *RepositoryAPIService) GetRefChangeActivityExecute(r ApiGetRefChangeActivityRequest) (*GetRefChangeActivity200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRefChangeActivity200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetRefChangeActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositories1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	archived *string
	projectname *string
	projectkey *string
	visibility *string
	name *string
	permission *string
	state *string
	start *float32
	limit *float32
}

// (optional) if specified, this will limit the resulting repository list to ones whose are &lt;tt&gt;ACTIVE&lt;/tt&gt;, &lt;tt&gt;ARCHIVED&lt;/tt&gt; or &lt;tt&gt;ALL&lt;/tt&gt; for both. The match performed is case-insensitive. This filter defaults to &lt;tt&gt;ACTIVE&lt;/tt&gt; when not set. &lt;em&gt;Available since 8.0&lt;/em&gt;
func (r ApiGetRepositories1Request) Archived(archived string) ApiGetRepositories1Request {
	r.archived = &archived
	return r
}

// (optional) if specified, this will limit the resulting repository list to ones whose project&#39;s name matches this parameter&#39;s value. The match performed is case-insensitive and any leading and/or trailing whitespace characters on the &lt;code&gt;projectname&lt;/code&gt; parameter will be stripped.
func (r ApiGetRepositories1Request) Projectname(projectname string) ApiGetRepositories1Request {
	r.projectname = &projectname
	return r
}

// (optional) if specified, this will limit the resulting repository list to ones whose project&#39;s key matches this parameter&#39;s value. The match performed is case-insensitive and any leading  and/or trailing whitespace characters on the &lt;code&gt;projectKey&lt;/code&gt; parameter will be stripped. &lt;em&gt;Available since 8.0&lt;/em&gt;
func (r ApiGetRepositories1Request) Projectkey(projectkey string) ApiGetRepositories1Request {
	r.projectkey = &projectkey
	return r
}

// (optional) if specified, this will limit the resulting repository list based on the repositories visibility. Valid values are &lt;em&gt;public&lt;/em&gt; or &lt;em&gt;private&lt;/em&gt;.
func (r ApiGetRepositories1Request) Visibility(visibility string) ApiGetRepositories1Request {
	r.visibility = &visibility
	return r
}

// (optional) if specified, this will limit the resulting repository list to ones whose name matches this parameter&#39;s value. The match performed is case-insensitive and any leading and/or trailing whitespace characters on the &lt;code&gt;name&lt;/code&gt; parameter will be stripped.
func (r ApiGetRepositories1Request) Name(name string) ApiGetRepositories1Request {
	r.name = &name
	return r
}

// (optional) if specified, it must be a valid repository permission level name and will limit the resulting repository list to ones that the requesting user has the specified permission level to. If not specified, the default implicit &#39;read&#39; permission level will be assumed. The currently supported explicit permission values are &lt;tt&gt;REPO_READ&lt;/tt&gt;, &lt;tt&gt;REPO_WRITE&lt;/tt&gt; and &lt;tt&gt;REPO_ADMIN&lt;/tt&gt;.
func (r ApiGetRepositories1Request) Permission(permission string) ApiGetRepositories1Request {
	r.permission = &permission
	return r
}

// (optional) if specified, it must be a valid repository state name and will limit the resulting repository list to ones that are in the specified state. The currently supported explicit state values are &lt;tt&gt;AVAILABLE&lt;/tt&gt;, &lt;tt&gt;INITIALISING&lt;/tt&gt; and &lt;tt&gt;INITIALISATION_FAILED&lt;/tt&gt;. Filtering by &lt;tt&gt;OFFLINE&lt;/tt&gt; repositories is not supported.&lt;br&gt;&lt;em&gt;Available since 5.13&lt;/em&gt;
func (r ApiGetRepositories1Request) State(state string) ApiGetRepositories1Request {
	r.state = &state
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetRepositories1Request) Start(start float32) ApiGetRepositories1Request {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetRepositories1Request) Limit(limit float32) ApiGetRepositories1Request {
	r.limit = &limit
	return r
}

func (r ApiGetRepositories1Request) Execute() (*GetRepositoriesRecentlyAccessed200Response, *http.Response, error) {
	return r.ApiService.GetRepositories1Execute(r)
}

/*
GetRepositories1 Search for repositories

Retrieve a page of repositories based on query parameters that control the search. See the documentation of the parameters for more details. 

This resource is anonymously accessible, if anonymous access is enabled. 

<b>Note on permissions.</b> In absence of the <code>permission</code> query parameter the implicit 'read' permission is assumed. Please note that this permission is lower than the <tt>REPO_READ</tt> permission rather than being equal to it. The implicit 'read' permission for a given repository is assigned to any user that has any of the higher permissions, such as <tt>REPO_READ</tt>, as well as to anonymous users if the repository is marked as public. The important implication of the above is that an anonymous request to this resource with a permission level <tt>REPO_READ</tt> is guaranteed to receive an empty list of repositories as a result. For anonymous requests it is therefore recommended to not specify the <tt>permission</tt> parameter at all.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepositories1Request
*/
func (a *RepositoryAPIService) GetRepositories1(ctx context.Context) ApiGetRepositories1Request {
	return ApiGetRepositories1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRepositoriesRecentlyAccessed200Response
func (a *RepositoryAPIService) GetRepositories1Execute(r ApiGetRepositories1Request) (*GetRepositoriesRecentlyAccessed200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRepositoriesRecentlyAccessed200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetRepositories1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/repos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.projectname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectname", r.projectname, "form", "")
	}
	if r.projectkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectkey", r.projectkey, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.permission != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permission", r.permission, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoriesRecentlyAccessedRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	permission *string
	start *float32
	limit *float32
}

// (optional) If specified, it must be a valid repository permission level name and will limit the resulting repository list to ones that the requesting user has the specified permission level to. If not specified, the default &lt;code&gt;REPO_READ&lt;/code&gt; permission level will be assumed.
func (r ApiGetRepositoriesRecentlyAccessedRequest) Permission(permission string) ApiGetRepositoriesRecentlyAccessedRequest {
	r.permission = &permission
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetRepositoriesRecentlyAccessedRequest) Start(start float32) ApiGetRepositoriesRecentlyAccessedRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetRepositoriesRecentlyAccessedRequest) Limit(limit float32) ApiGetRepositoriesRecentlyAccessedRequest {
	r.limit = &limit
	return r
}

func (r ApiGetRepositoriesRecentlyAccessedRequest) Execute() (*GetRepositoriesRecentlyAccessed200Response, *http.Response, error) {
	return r.ApiService.GetRepositoriesRecentlyAccessedExecute(r)
}

/*
GetRepositoriesRecentlyAccessed Get recently accessed repositories

Retrieve a page of recently accessed repositories for the currently authenticated user. 

Repositories are ordered from most recently to least recently accessed. <p>Only authenticated users may call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepositoriesRecentlyAccessedRequest
*/
func (a *RepositoryAPIService) GetRepositoriesRecentlyAccessed(ctx context.Context) ApiGetRepositoriesRecentlyAccessedRequest {
	return ApiGetRepositoriesRecentlyAccessedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRepositoriesRecentlyAccessed200Response
func (a *RepositoryAPIService) GetRepositoriesRecentlyAccessedExecute(r ApiGetRepositoriesRecentlyAccessedRequest) (*GetRepositoriesRecentlyAccessed200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRepositoriesRecentlyAccessed200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetRepositoriesRecentlyAccessed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/profile/recent/repos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.permission != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permission", r.permission, "form", "")
	} else {
		var defaultValue string = "REPO_READ"
		r.permission = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryHook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	hookKey string
	repositorySlug string
}

func (r ApiGetRepositoryHook1Request) Execute() (*RestRepositoryHook, *http.Response, error) {
	return r.ApiService.GetRepositoryHook1Execute(r)
}

/*
GetRepositoryHook1 Get repository hook

Retrieve a repository hook for this repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param hookKey The hook key.
 @param repositorySlug The repository slug.
 @return ApiGetRepositoryHook1Request
*/
func (a *RepositoryAPIService) GetRepositoryHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) ApiGetRepositoryHook1Request {
	return ApiGetRepositoryHook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		hookKey: hookKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRepositoryHook
func (a *RepositoryAPIService) GetRepositoryHook1Execute(r ApiGetRepositoryHook1Request) (*RestRepositoryHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRepositoryHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetRepositoryHook1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hookKey"+"}", url.PathEscape(parameterValueToString(r.hookKey, "hookKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryHooks1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	type_ *string
	start *float32
	limit *float32
}

// The optional type to filter by.
func (r ApiGetRepositoryHooks1Request) Type_(type_ string) ApiGetRepositoryHooks1Request {
	r.type_ = &type_
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetRepositoryHooks1Request) Start(start float32) ApiGetRepositoryHooks1Request {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetRepositoryHooks1Request) Limit(limit float32) ApiGetRepositoryHooks1Request {
	r.limit = &limit
	return r
}

func (r ApiGetRepositoryHooks1Request) Execute() (*GetRepositoryHooks1200Response, *http.Response, error) {
	return r.ApiService.GetRepositoryHooks1Execute(r)
}

/*
GetRepositoryHooks1 Get repository hooks

Retrieve a page of repository hooks for this repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetRepositoryHooks1Request
*/
func (a *RepositoryAPIService) GetRepositoryHooks1(ctx context.Context, projectKey string, repositorySlug string) ApiGetRepositoryHooks1Request {
	return ApiGetRepositoryHooks1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetRepositoryHooks1200Response
func (a *RepositoryAPIService) GetRepositoryHooks1Execute(r ApiGetRepositoryHooks1Request) (*GetRepositoryHooks1200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRepositoryHooks1200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetRepositoryHooks1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRestriction1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	id string
	repositorySlug string
}

func (r ApiGetRestriction1Request) Execute() (*RestRefRestriction, *http.Response, error) {
	return r.ApiService.GetRestriction1Execute(r)
}

/*
GetRestriction1 Get a ref restriction

Returns a restriction as specified by a restriction id. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param id The restriction id.
 @param repositorySlug The repository slug.
 @return ApiGetRestriction1Request
*/
func (a *RepositoryAPIService) GetRestriction1(ctx context.Context, projectKey string, id string, repositorySlug string) ApiGetRestriction1Request {
	return ApiGetRestriction1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		id: id,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRefRestriction
func (a *RepositoryAPIService) GetRestriction1Execute(r ApiGetRestriction1Request) (*RestRefRestriction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRefRestriction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetRestriction1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRestrictions1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	matcherType *string
	matcherId *string
	type_ *string
	start *float32
	limit *float32
}

// Matcher type to filter on
func (r ApiGetRestrictions1Request) MatcherType(matcherType string) ApiGetRestrictions1Request {
	r.matcherType = &matcherType
	return r
}

// Matcher id to filter on. Requires the matcherType parameter to be specified also.
func (r ApiGetRestrictions1Request) MatcherId(matcherId string) ApiGetRestrictions1Request {
	r.matcherId = &matcherId
	return r
}

// Types of restrictions to filter on.
func (r ApiGetRestrictions1Request) Type_(type_ string) ApiGetRestrictions1Request {
	r.type_ = &type_
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetRestrictions1Request) Start(start float32) ApiGetRestrictions1Request {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetRestrictions1Request) Limit(limit float32) ApiGetRestrictions1Request {
	r.limit = &limit
	return r
}

func (r ApiGetRestrictions1Request) Execute() (*GetRestrictions1200Response, *http.Response, error) {
	return r.ApiService.GetRestrictions1Execute(r)
}

/*
GetRestrictions1 Search for ref restrictions

Search for restrictions using the supplied parameters.

The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetRestrictions1Request
*/
func (a *RepositoryAPIService) GetRestrictions1(ctx context.Context, projectKey string, repositorySlug string) ApiGetRestrictions1Request {
	return ApiGetRestrictions1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetRestrictions1200Response
func (a *RepositoryAPIService) GetRestrictions1Execute(r ApiGetRestrictions1Request) (*GetRestrictions1200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRestrictions1200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetRestrictions1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.matcherType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matcherType", r.matcherType, "form", "")
	}
	if r.matcherId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matcherId", r.matcherId, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSettings1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	hookKey string
	repositorySlug string
}

func (r ApiGetSettings1Request) Execute() (*ExampleSettings, *http.Response, error) {
	return r.ApiService.GetSettings1Execute(r)
}

/*
GetSettings1 Get repository hook settings

Retrieve the settings for a repository hook for this repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param hookKey The hook key.
 @param repositorySlug The repository slug.
 @return ApiGetSettings1Request
*/
func (a *RepositoryAPIService) GetSettings1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) ApiGetSettings1Request {
	return ApiGetSettings1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		hookKey: hookKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return ExampleSettings
func (a *RepositoryAPIService) GetSettings1Execute(r ApiGetSettings1Request) (*ExampleSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetSettings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hookKey"+"}", url.PathEscape(parameterValueToString(r.hookKey, "hookKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatistics1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	webhookId string
	repositorySlug string
	event *string
}

// The string ID of a specific event to retrieve the last invocation for. May be empty, in which case all events are considered
func (r ApiGetStatistics1Request) Event(event string) ApiGetStatistics1Request {
	r.event = &event
	return r
}

func (r ApiGetStatistics1Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetStatistics1Execute(r)
}

/*
GetStatistics1 Get webhook statistics

Get the statistics for a specific webhook. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param webhookId ID of the webhook
 @param repositorySlug The repository slug.
 @return ApiGetStatistics1Request
*/
func (a *RepositoryAPIService) GetStatistics1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) ApiGetStatistics1Request {
	return ApiGetStatistics1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		webhookId: webhookId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return interface{}
func (a *RepositoryAPIService) GetStatistics1Execute(r ApiGetStatistics1Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetStatistics1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhookId"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatisticsSummary1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	webhookId string
	repositorySlug string
}

func (r ApiGetStatisticsSummary1Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetStatisticsSummary1Execute(r)
}

/*
GetStatisticsSummary1 Get webhook statistics summary

Get the statistics summary for a specific webhook. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param webhookId ID of the webhook
 @param repositorySlug The repository slug.
 @return ApiGetStatisticsSummary1Request
*/
func (a *RepositoryAPIService) GetStatisticsSummary1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) ApiGetStatisticsSummary1Request {
	return ApiGetStatisticsSummary1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		webhookId: webhookId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return interface{}
func (a *RepositoryAPIService) GetStatisticsSummary1Execute(r ApiGetStatisticsSummary1Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetStatisticsSummary1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhookId"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	name string
	repositorySlug string
}

func (r ApiGetTagRequest) Execute() (*RestTag, *http.Response, error) {
	return r.ApiService.GetTagExecute(r)
}

/*
GetTag Get tag

Retrieve a tag in the specified repository. 

The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param name The name of the tag to be retrieved.
 @param repositorySlug The repository slug.
 @return ApiGetTagRequest
*/
func (a *RepositoryAPIService) GetTag(ctx context.Context, projectKey string, name string, repositorySlug string) ApiGetTagRequest {
	return ApiGetTagRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		name: name,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestTag
func (a *RepositoryAPIService) GetTagExecute(r ApiGetTagRequest) (*RestTag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestTag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	orderBy *string
	filterText *string
	start *float32
	limit *float32
}

// Ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated)
func (r ApiGetTagsRequest) OrderBy(orderBy string) ApiGetTagsRequest {
	r.orderBy = &orderBy
	return r
}

// The text to match on.
func (r ApiGetTagsRequest) FilterText(filterText string) ApiGetTagsRequest {
	r.filterText = &filterText
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiGetTagsRequest) Start(start float32) ApiGetTagsRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiGetTagsRequest) Limit(limit float32) ApiGetTagsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTagsRequest) Execute() (*GetTags200Response, *http.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags Find tag

Retrieve the tags matching the supplied <strong>filterText</strong> param. 

The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiGetTagsRequest
*/
func (a *RepositoryAPIService) GetTags(ctx context.Context, projectKey string, repositorySlug string) ApiGetTagsRequest {
	return ApiGetTagsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetTags200Response
func (a *RepositoryAPIService) GetTagsExecute(r ApiGetTagsRequest) (*GetTags200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTags200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.filterText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterText", r.filterText, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	webhookId string
	repositorySlug string
	statistics *string
}

// &lt;code&gt;true&lt;/code&gt; if statistics should be provided for the webhook
func (r ApiGetWebhook1Request) Statistics(statistics string) ApiGetWebhook1Request {
	r.statistics = &statistics
	return r
}

func (r ApiGetWebhook1Request) Execute() (*RestWebhook, *http.Response, error) {
	return r.ApiService.GetWebhook1Execute(r)
}

/*
GetWebhook1 Get webhook

Get a webhook by ID. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param webhookId ID of the webhook
 @param repositorySlug The repository slug.
 @return ApiGetWebhook1Request
*/
func (a *RepositoryAPIService) GetWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) ApiGetWebhook1Request {
	return ApiGetWebhook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		webhookId: webhookId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestWebhook
func (a *RepositoryAPIService) GetWebhook1Execute(r ApiGetWebhook1Request) (*RestWebhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestWebhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.GetWebhook1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhookId"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.statistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statistics", r.statistics, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMGetStatusRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	at *string
}

// Retrieves the synchronization status for the specified ref within the repository, rather than for the entire repository
func (r ApiMGetStatusRequest) At(at string) ApiMGetStatusRequest {
	r.at = &at
	return r
}

func (r ApiMGetStatusRequest) Execute() (*RestRefSyncStatus, *http.Response, error) {
	return r.ApiService.MGetStatusExecute(r)
}

/*
MGetStatus Get synchronization status

Retrieves the synchronization status for the specified repository. In addition to listing refs which cannot be synchronized, if any, the status also provides the timestamp for the most recent synchronization and indicates whether synchronization is available and enabled. If "?at" is specified in the URL, the synchronization status for the specified ref is returned, rather than the complete repository status.

The authenticated user must have <b>REPO_READ</b> permission for the repository, or it must be public if the request is anonymous. Additionally, after synchronization is enabled for a repository, meaning synchronization was available at that time, permission changes and other actions can cause it to become unavailable. Even when synchronization is enabled, if it is no longer available for the repository it will not be performed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiMGetStatusRequest
*/
func (a *RepositoryAPIService) MGetStatus(ctx context.Context, projectKey string, repositorySlug string) ApiMGetStatusRequest {
	return ApiMGetStatusRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRefSyncStatus
func (a *RepositoryAPIService) MGetStatusExecute(r ApiMGetStatusRequest) (*RestRefSyncStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRefSyncStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.MGetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commentId string
	commitId string
	emoticon string
	repositorySlug string
}

func (r ApiReactRequest) Execute() (*RestUserReaction, *http.Response, error) {
	return r.ApiService.ReactExecute(r)
}

/*
React React to a comment

Add an emoticon reaction to a comment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commentId The comment id
 @param commitId The commit id
 @param emoticon The emoticon to add
 @param repositorySlug The repository slug.
 @return ApiReactRequest
*/
func (a *RepositoryAPIService) React(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) ApiReactRequest {
	return ApiReactRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commentId: commentId,
		commitId: commitId,
		emoticon: emoticon,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestUserReaction
func (a *RepositoryAPIService) ReactExecute(r ApiReactRequest) (*RestUserReaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestUserReaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.React")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"emoticon"+"}", url.PathEscape(parameterValueToString(r.emoticon, "emoticon")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveConfiguration1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	scriptId string
	repositorySlug string
}

func (r ApiRemoveConfiguration1Request) Execute() (*http.Response, error) {
	return r.ApiService.RemoveConfiguration1Execute(r)
}

/*
RemoveConfiguration1 Remove a hook script

Removes the hook script from the set of hook scripts configured to run in the repository. 

This endpoint requires **REPO_ADMIN** permission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param scriptId The ID of the hook script
 @param repositorySlug The repository slug.
 @return ApiRemoveConfiguration1Request
*/
func (a *RepositoryAPIService) RemoveConfiguration1(ctx context.Context, projectKey string, scriptId string, repositorySlug string) ApiRemoveConfiguration1Request {
	return ApiRemoveConfiguration1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		scriptId: scriptId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) RemoveConfiguration1Execute(r ApiRemoveConfiguration1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.RemoveConfiguration1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scriptId"+"}", url.PathEscape(parameterValueToString(r.scriptId, "scriptId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveLabelRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	labelName string
	repositorySlug string
}

func (r ApiRemoveLabelRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveLabelExecute(r)
}

/*
RemoveLabel Remove repository label

Remove label that is applied to the given repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param labelName The label to remove
 @param repositorySlug The repository slug.
 @return ApiRemoveLabelRequest
*/
func (a *RepositoryAPIService) RemoveLabel(ctx context.Context, projectKey string, labelName string, repositorySlug string) ApiRemoveLabelRequest {
	return ApiRemoveLabelRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		labelName: labelName,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) RemoveLabelExecute(r ApiRemoveLabelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.RemoveLabel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels/{labelName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"labelName"+"}", url.PathEscape(parameterValueToString(r.labelName, "labelName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSaveAttachmentMetadataRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	attachmentId string
	repositorySlug string
	body *string
}

// The attachment metadata can be any valid JSON content
func (r ApiSaveAttachmentMetadataRequest) Body(body string) ApiSaveAttachmentMetadataRequest {
	r.body = &body
	return r
}

func (r ApiSaveAttachmentMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.SaveAttachmentMetadataExecute(r)
}

/*
SaveAttachmentMetadata Save attachment metadata

Save attachment metadata.

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment that has the attachment metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param attachmentId the attachment ID
 @param repositorySlug The repository slug
 @return ApiSaveAttachmentMetadataRequest
*/
func (a *RepositoryAPIService) SaveAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) ApiSaveAttachmentMetadataRequest {
	return ApiSaveAttachmentMetadataRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		attachmentId: attachmentId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) SaveAttachmentMetadataExecute(r ApiSaveAttachmentMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.SaveAttachmentMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchWebhooksRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	scopeType *string
	event *string
	statistics *bool
}

// Scopes to filter by. This parameter can be specified once e.g. \&quot;scopeType&#x3D;repository\&quot;, or twice e.g. \&quot;scopeType&#x3D;repository&amp;scopeType&#x3D;project\&quot;, to filter by more than one scope level. 
func (r ApiSearchWebhooksRequest) ScopeType(scopeType string) ApiSearchWebhooksRequest {
	r.scopeType = &scopeType
	return r
}

// List of &lt;code&gt;com.atlassian.webhooks.WebhookEvent&lt;/code&gt; ids to filter for
func (r ApiSearchWebhooksRequest) Event(event string) ApiSearchWebhooksRequest {
	r.event = &event
	return r
}

// &lt;code&gt;true&lt;/code&gt; if statistics should be provided for all found webhooks
func (r ApiSearchWebhooksRequest) Statistics(statistics bool) ApiSearchWebhooksRequest {
	r.statistics = &statistics
	return r
}

func (r ApiSearchWebhooksRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchWebhooksExecute(r)
}

/*
SearchWebhooks Search webhooks

Search webhooks in this repository and parent project. This endpoint returns a superset of the results returned by the /webhooks endpoint because it allows filtering by project scope too, not just repository webhooks.

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiSearchWebhooksRequest
*/
func (a *RepositoryAPIService) SearchWebhooks(ctx context.Context, projectKey string, repositorySlug string) ApiSearchWebhooksRequest {
	return ApiSearchWebhooksRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) SearchWebhooksExecute(r ApiSearchWebhooksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.SearchWebhooks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/search"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scopeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scopeType", r.scopeType, "form", "")
	}
	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	if r.statistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statistics", r.statistics, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSet1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restAutoMergeSettingsRequest *RestAutoMergeSettingsRequest
}

// The settings to create or update
func (r ApiSet1Request) RestAutoMergeSettingsRequest(restAutoMergeSettingsRequest RestAutoMergeSettingsRequest) ApiSet1Request {
	r.restAutoMergeSettingsRequest = &restAutoMergeSettingsRequest
	return r
}

func (r ApiSet1Request) Execute() (*RestAutoMergeRestrictedSettings, *http.Response, error) {
	return r.ApiService.Set1Execute(r)
}

/*
Set1 Create or update the pull request auto-merge settings

Creates or updates the pull request auto-merge settings for the supplied repository.

The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiSet1Request
*/
func (a *RepositoryAPIService) Set1(ctx context.Context, projectKey string, repositorySlug string) ApiSet1Request {
	return ApiSet1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestAutoMergeRestrictedSettings
func (a *RepositoryAPIService) Set1Execute(r ApiSet1Request) (*RestAutoMergeRestrictedSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestAutoMergeRestrictedSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Set1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restAutoMergeSettingsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetAutoDeclineSettings1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restAutoDeclineSettingsRequest *RestAutoDeclineSettingsRequest
}

// The settings to create or update
func (r ApiSetAutoDeclineSettings1Request) RestAutoDeclineSettingsRequest(restAutoDeclineSettingsRequest RestAutoDeclineSettingsRequest) ApiSetAutoDeclineSettings1Request {
	r.restAutoDeclineSettingsRequest = &restAutoDeclineSettingsRequest
	return r
}

func (r ApiSetAutoDeclineSettings1Request) Execute() (*RestAutoDeclineSettings, *http.Response, error) {
	return r.ApiService.SetAutoDeclineSettings1Execute(r)
}

/*
SetAutoDeclineSettings1 Create auto decline settings

Creates or updates the auto decline settings for the supplied repository.

The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiSetAutoDeclineSettings1Request
*/
func (a *RepositoryAPIService) SetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string) ApiSetAutoDeclineSettings1Request {
	return ApiSetAutoDeclineSettings1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestAutoDeclineSettings
func (a *RepositoryAPIService) SetAutoDeclineSettings1Execute(r ApiSetAutoDeclineSettings1Request) (*RestAutoDeclineSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestAutoDeclineSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.SetAutoDeclineSettings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restAutoDeclineSettingsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetConfiguration1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	scriptId string
	repositorySlug string
	restHookScriptTriggers *RestHookScriptTriggers
}

// The hook triggers for which the hook script should be run
func (r ApiSetConfiguration1Request) RestHookScriptTriggers(restHookScriptTriggers RestHookScriptTriggers) ApiSetConfiguration1Request {
	r.restHookScriptTriggers = &restHookScriptTriggers
	return r
}

func (r ApiSetConfiguration1Request) Execute() (*RestHookScriptConfig, *http.Response, error) {
	return r.ApiService.SetConfiguration1Execute(r)
}

/*
SetConfiguration1 Create/update a hook script

Creates/updates the hook script configuration for the provided hook script and repository. 

This endpoint requires **REPO_ADMIN** permission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param scriptId The ID of the hook script
 @param repositorySlug The repository slug.
 @return ApiSetConfiguration1Request
*/
func (a *RepositoryAPIService) SetConfiguration1(ctx context.Context, projectKey string, scriptId string, repositorySlug string) ApiSetConfiguration1Request {
	return ApiSetConfiguration1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		scriptId: scriptId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestHookScriptConfig
func (a *RepositoryAPIService) SetConfiguration1Execute(r ApiSetConfiguration1Request) (*RestHookScriptConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestHookScriptConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.SetConfiguration1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scriptId"+"}", url.PathEscape(parameterValueToString(r.scriptId, "scriptId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restHookScriptTriggers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDefaultBranch1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restBranch *RestBranch
}

// The branch to set as default
func (r ApiSetDefaultBranch1Request) RestBranch(restBranch RestBranch) ApiSetDefaultBranch1Request {
	r.restBranch = &restBranch
	return r
}

func (r ApiSetDefaultBranch1Request) Execute() (*http.Response, error) {
	return r.ApiService.SetDefaultBranch1Execute(r)
}

/*
SetDefaultBranch1 Update default branch

Update the default branch of a repository. 

This URL is deprecated. Callers should use <code>PUT /projects/{key}/repos/{slug}/default-branch</code> instead. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiSetDefaultBranch1Request

Deprecated
*/
func (a *RepositoryAPIService) SetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string) ApiSetDefaultBranch1Request {
	return ApiSetDefaultBranch1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
// Deprecated
func (a *RepositoryAPIService) SetDefaultBranch1Execute(r ApiSetDefaultBranch1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.SetDefaultBranch1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restBranch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetEnabledRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restRefSyncStatus *RestRefSyncStatus
}

func (r ApiSetEnabledRequest) RestRefSyncStatus(restRefSyncStatus RestRefSyncStatus) ApiSetEnabledRequest {
	r.restRefSyncStatus = &restRefSyncStatus
	return r
}

func (r ApiSetEnabledRequest) Execute() (*RestRefSyncStatus, *http.Response, error) {
	return r.ApiService.SetEnabledExecute(r)
}

/*
SetEnabled Disable synchronization

Enables or disables synchronization for the specified repository. When synchronization is enabled, branches within the repository are immediately synchronized and the status is updated with the outcome. That initial synchronization is performed before the REST request returns, allowing it to return the updated status.

The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository. Anonymous users cannot manage synchronization, even on public repositories. Additionally, synchronization must be available for the specified repository. Synchronization is only available if:

- The repository is a fork, since its origin is used as upstream
- The owning user still has access to the fork's origin,  if the repository is a <i>personalfork</i>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiSetEnabledRequest
*/
func (a *RepositoryAPIService) SetEnabled(ctx context.Context, projectKey string, repositorySlug string) ApiSetEnabledRequest {
	return ApiSetEnabledRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRefSyncStatus
func (a *RepositoryAPIService) SetEnabledExecute(r ApiSetEnabledRequest) (*RestRefSyncStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRefSyncStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.SetEnabled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restRefSyncStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetSettings1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	hookKey string
	repositorySlug string
	exampleSettings *ExampleSettings
}

// The raw settings.
func (r ApiSetSettings1Request) ExampleSettings(exampleSettings ExampleSettings) ApiSetSettings1Request {
	r.exampleSettings = &exampleSettings
	return r
}

func (r ApiSetSettings1Request) Execute() (*ExampleSettings, *http.Response, error) {
	return r.ApiService.SetSettings1Execute(r)
}

/*
SetSettings1 Update repository hook settings

Modify the settings for a repository hook for this repository. 

The service will reject any settings which are too large, the current limit is 32KB once serialized. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource. 

A JSON document can be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param hookKey The hook key.
 @param repositorySlug The repository slug.
 @return ApiSetSettings1Request
*/
func (a *RepositoryAPIService) SetSettings1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) ApiSetSettings1Request {
	return ApiSetSettings1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		hookKey: hookKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return ExampleSettings
func (a *RepositoryAPIService) SetSettings1Execute(r ApiSetSettings1Request) (*ExampleSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.SetSettings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hookKey"+"}", url.PathEscape(parameterValueToString(r.hookKey, "hookKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exampleSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	at *string
}

// The commit to use as the starting point when listing files and calculating modifications
func (r ApiStreamRequest) At(at string) ApiStreamRequest {
	r.at = &at
	return r
}

func (r ApiStreamRequest) Execute() (*ExampleFiles, *http.Response, error) {
	return r.ApiService.StreamExecute(r)
}

/*
Stream Stream files

Streams files from the repository's root with the last commit to modify each file. Commit modifications are traversed starting from the <code>at</code> commit or, if not specified, from the tip of the default branch.

Unless the repository is public, the authenticated user must have <b>REPO_READ</b> access to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiStreamRequest
*/
func (a *RepositoryAPIService) Stream(ctx context.Context, projectKey string, repositorySlug string) ApiStreamRequest {
	return ApiStreamRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return ExampleFiles
func (a *RepositoryAPIService) StreamExecute(r ApiStreamRequest) (*ExampleFiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleFiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Stream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStream1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	at *string
}

// The commit to use as the starting point when listing files and calculating modifications
func (r ApiStream1Request) At(at string) ApiStream1Request {
	r.at = &at
	return r
}

func (r ApiStream1Request) Execute() (*ExampleFiles, *http.Response, error) {
	return r.ApiService.Stream1Execute(r)
}

/*
Stream1 Stream files with last modified commit in path

Streams files in the requested <code>path</code> with the last commit to modify each file. Commit modifications are traversed starting from the <code>at</code> commit or, if not specified, from the tip of the default branch.

Unless the repository is public, the authenticated user must have <b>REPO_READ</b> access to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The path within the repository whose files should be streamed
 @param projectKey The project key
 @param repositorySlug The repository slug
 @return ApiStream1Request
*/
func (a *RepositoryAPIService) Stream1(ctx context.Context, path string, projectKey string, repositorySlug string) ApiStream1Request {
	return ApiStream1Request{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return ExampleFiles
func (a *RepositoryAPIService) Stream1Execute(r ApiStream1Request) (*ExampleFiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleFiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Stream1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamChangesRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	fromRepo *string
	from *string
	to *string
	start *float32
	limit *float32
}

// an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt;
func (r ApiStreamChangesRequest) FromRepo(fromRepo string) ApiStreamChangesRequest {
	r.fromRepo = &fromRepo
	return r
}

// the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiStreamChangesRequest) From(from string) ApiStreamChangesRequest {
	r.from = &from
	return r
}

// the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiStreamChangesRequest) To(to string) ApiStreamChangesRequest {
	r.to = &to
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiStreamChangesRequest) Start(start float32) ApiStreamChangesRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiStreamChangesRequest) Limit(limit float32) ApiStreamChangesRequest {
	r.limit = &limit
	return r
}

func (r ApiStreamChangesRequest) Execute() (*GetChanges1200Response, *http.Response, error) {
	return r.ApiService.StreamChangesExecute(r)
}

/*
StreamChanges Compare commits

Gets the file changes available in the <code> from</code> commit but not in the <code> to</code> commit.


If either the <code> from</code> or <code> to</code> commit are not specified, they will be replaced by the default branch of their containing repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamChangesRequest
*/
func (a *RepositoryAPIService) StreamChanges(ctx context.Context, projectKey string, repositorySlug string) ApiStreamChangesRequest {
	return ApiStreamChangesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetChanges1200Response
func (a *RepositoryAPIService) StreamChangesExecute(r ApiStreamChangesRequest) (*GetChanges1200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChanges1200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromRepo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRepo", r.fromRepo, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamCommitsRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	fromRepo *string
	from *string
	to *string
	start *float32
	limit *float32
}

// an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt;
func (r ApiStreamCommitsRequest) FromRepo(fromRepo string) ApiStreamCommitsRequest {
	r.fromRepo = &fromRepo
	return r
}

// the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiStreamCommitsRequest) From(from string) ApiStreamCommitsRequest {
	r.from = &from
	return r
}

// the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiStreamCommitsRequest) To(to string) ApiStreamCommitsRequest {
	r.to = &to
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiStreamCommitsRequest) Start(start float32) ApiStreamCommitsRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiStreamCommitsRequest) Limit(limit float32) ApiStreamCommitsRequest {
	r.limit = &limit
	return r
}

func (r ApiStreamCommitsRequest) Execute() (*GetCommits200Response, *http.Response, error) {
	return r.ApiService.StreamCommitsExecute(r)
}

/*
StreamCommits Get accessible commits

Gets the commits accessible from the <code>from</code> commit but not in the <code>to</code> commit.

If either the <code>from</code> or <code>to</code> commit are not specified, they will be replaced by the default branch of their containing repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamCommitsRequest
*/
func (a *RepositoryAPIService) StreamCommits(ctx context.Context, projectKey string, repositorySlug string) ApiStreamCommitsRequest {
	return ApiStreamCommitsRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return GetCommits200Response
func (a *RepositoryAPIService) StreamCommitsExecute(r ApiStreamCommitsRequest) (*GetCommits200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCommits200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamCommits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/commits"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromRepo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRepo", r.fromRepo, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamDiffRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	commitId string
	repositorySlug string
	path string
	projectKey string
	srcPath *string
	avatarSize *string
	filter *string
	avatarScheme *string
	contextLines *string
	autoSrcPath *string
	whitespace *string
	withComments *string
	since *string
}

// The source path for the file, if it was copied, moved or renamed
func (r ApiStreamDiffRequest) SrcPath(srcPath string) ApiStreamDiffRequest {
	r.srcPath = &srcPath
	return r
}

// If present the service adds avatar URLs for comment authors where the provided value specifies the desired avatar size in pixels. Not applicable if streaming raw diff
func (r ApiStreamDiffRequest) AvatarSize(avatarSize string) ApiStreamDiffRequest {
	r.avatarSize = &avatarSize
	return r
}

// Text used to filter files and lines (optional). Not applicable if streaming raw diff
func (r ApiStreamDiffRequest) Filter(filter string) ApiStreamDiffRequest {
	r.filter = &filter
	return r
}

// The security scheme for avatar URLs. If the scheme is not present then it is inherited from the request. It can be set to \&quot;https\&quot; to force the use of secure URLs. Not applicable if streaming raw diff
func (r ApiStreamDiffRequest) AvatarScheme(avatarScheme string) ApiStreamDiffRequest {
	r.avatarScheme = &avatarScheme
	return r
}

// The number of context lines to include around added/removed lines in the diff.Not applicable if streaming raw diff
func (r ApiStreamDiffRequest) ContextLines(contextLines string) ApiStreamDiffRequest {
	r.contextLines = &contextLines
	return r
}

// &lt;code&gt;true&lt;/code&gt; to automatically try to find the source path when it&#39;s not provided, &lt;code&gt;false&lt;/code&gt; otherwise. Requires the path to be provided.
func (r ApiStreamDiffRequest) AutoSrcPath(autoSrcPath string) ApiStreamDiffRequest {
	r.autoSrcPath = &autoSrcPath
	return r
}

// Optional whitespace flag which can be set to ignore-all
func (r ApiStreamDiffRequest) Whitespace(whitespace string) ApiStreamDiffRequest {
	r.whitespace = &whitespace
	return r
}

// &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise &lt;code&gt;false&lt;/code&gt; to stream the diff without comments. Not applicable if streaming raw diff
func (r ApiStreamDiffRequest) WithComments(withComments string) ApiStreamDiffRequest {
	r.withComments = &withComments
	return r
}

// The base revision to diff from. If omitted the parent revision of the until revision is used
func (r ApiStreamDiffRequest) Since(since string) ApiStreamDiffRequest {
	r.since = &since
	return r
}

func (r ApiStreamDiffRequest) Execute() (*RestDiff, *http.Response, error) {
	return r.ApiService.StreamDiffExecute(r)
}

/*
StreamDiff Get diff between revisions

Retrieve the diff between two provided revisions.

To stream a raw text representation of the diff, this endpoint can be called with the request header 'Accept: text/plain'. 

Note:</strong> This resource is currently <i>not paged</i>. The server will internally apply a hard cap to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded. In the event that the cap is reached, the diff will be cut short and one or more {@code truncated} flags will be set to true on the "segments", "hunks" and "diffs" properties, as well as the top-level object, in the returned JSON response.

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @param path The path to the file which should be diffed (optional)
 @param projectKey The project key
 @return ApiStreamDiffRequest
*/
func (a *RepositoryAPIService) StreamDiff(ctx context.Context, commitId string, repositorySlug string, path string, projectKey string) ApiStreamDiffRequest {
	return ApiStreamDiffRequest{
		ApiService: a,
		ctx: ctx,
		commitId: commitId,
		repositorySlug: repositorySlug,
		path: path,
		projectKey: projectKey,
	}
}

// Execute executes the request
//  @return RestDiff
func (a *RepositoryAPIService) StreamDiffExecute(r ApiStreamDiffRequest) (*RestDiff, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDiff
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamDiff")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.srcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "srcPath", r.srcPath, "form", "")
	}
	if r.avatarSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avatarSize", r.avatarSize, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.avatarScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avatarScheme", r.avatarScheme, "form", "")
	}
	if r.contextLines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contextLines", r.contextLines, "form", "")
	}
	if r.autoSrcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoSrcPath", r.autoSrcPath, "form", "")
	}
	if r.whitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whitespace", r.whitespace, "form", "")
	}
	if r.withComments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withComments", r.withComments, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamDiff1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	contextLines *string
	fromRepo *string
	srcPath *string
	from *string
	to *string
	whitespace *string
}

// an optional number of context lines to include around each added or removed lines in the diff
func (r ApiStreamDiff1Request) ContextLines(contextLines string) ApiStreamDiff1Request {
	r.contextLines = &contextLines
	return r
}

// an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt;
func (r ApiStreamDiff1Request) FromRepo(fromRepo string) ApiStreamDiff1Request {
	r.fromRepo = &fromRepo
	return r
}

// source path
func (r ApiStreamDiff1Request) SrcPath(srcPath string) ApiStreamDiff1Request {
	r.srcPath = &srcPath
	return r
}

// the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiStreamDiff1Request) From(from string) ApiStreamDiff1Request {
	r.from = &from
	return r
}

// the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r ApiStreamDiff1Request) To(to string) ApiStreamDiff1Request {
	r.to = &to
	return r
}

// an optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt;
func (r ApiStreamDiff1Request) Whitespace(whitespace string) ApiStreamDiff1Request {
	r.whitespace = &whitespace
	return r
}

func (r ApiStreamDiff1Request) Execute() (*RestDiff, *http.Response, error) {
	return r.ApiService.StreamDiff1Execute(r)
}

/*
StreamDiff1 Get diff between commits

Gets a diff of the changes available in the <code>from</code> commit but not in the <code> to</code> commit.

If either the <code> from</code> or <code> to</code> commit are not specified, they will be replaced by the default branch of their containing repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path the path to the file to diff (optional)
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamDiff1Request
*/
func (a *RepositoryAPIService) StreamDiff1(ctx context.Context, path string, projectKey string, repositorySlug string) ApiStreamDiff1Request {
	return ApiStreamDiff1Request{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestDiff
func (a *RepositoryAPIService) StreamDiff1Execute(r ApiStreamDiff1Request) (*RestDiff, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDiff
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamDiff1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/diff{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contextLines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contextLines", r.contextLines, "form", "")
	}
	if r.fromRepo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRepo", r.fromRepo, "form", "")
	}
	if r.srcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "srcPath", r.srcPath, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	if r.whitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whitespace", r.whitespace, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamFilesRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	at *string
	start *float32
	limit *float32
}

// The commit ID or ref (e.g. a branch or tag) to list the files at. If not specified the default branch will be used instead.
func (r ApiStreamFilesRequest) At(at string) ApiStreamFilesRequest {
	r.at = &at
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiStreamFilesRequest) Start(start float32) ApiStreamFilesRequest {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiStreamFilesRequest) Limit(limit float32) ApiStreamFilesRequest {
	r.limit = &limit
	return r
}

func (r ApiStreamFilesRequest) Execute() (*StreamFiles200Response, *http.Response, error) {
	return r.ApiService.StreamFilesExecute(r)
}

/*
StreamFiles Get files in directory

Retrieve a page of files from particular directory of a repository. The search is done recursively, so all files from any sub-directory of the specified directory will be returned. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamFilesRequest
*/
func (a *RepositoryAPIService) StreamFiles(ctx context.Context, projectKey string, repositorySlug string) ApiStreamFilesRequest {
	return ApiStreamFilesRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return StreamFiles200Response
func (a *RepositoryAPIService) StreamFilesExecute(r ApiStreamFilesRequest) (*StreamFiles200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StreamFiles200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamFiles1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	at *string
	start *float32
	limit *float32
}

// The commit ID or ref (e.g. a branch or tag) to list the files at. If not specified the default branch will be used instead.
func (r ApiStreamFiles1Request) At(at string) ApiStreamFiles1Request {
	r.at = &at
	return r
}

// Start number for the page (inclusive). If not passed, first page is assumed.
func (r ApiStreamFiles1Request) Start(start float32) ApiStreamFiles1Request {
	r.start = &start
	return r
}

// Number of items to return. If not passed, a page size of 25 is used.
func (r ApiStreamFiles1Request) Limit(limit float32) ApiStreamFiles1Request {
	r.limit = &limit
	return r
}

func (r ApiStreamFiles1Request) Execute() (*StreamFiles200Response, *http.Response, error) {
	return r.ApiService.StreamFiles1Execute(r)
}

/*
StreamFiles1 Get files in directory

Retrieve a page of files from particular directory of a repository. The search is done recursively, so all files from any sub-directory of the specified directory will be returned. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The directory to list files for.
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamFiles1Request
*/
func (a *RepositoryAPIService) StreamFiles1(ctx context.Context, path string, projectKey string, repositorySlug string) ApiStreamFiles1Request {
	return ApiStreamFiles1Request{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return StreamFiles200Response
func (a *RepositoryAPIService) StreamFiles1Execute(r ApiStreamFiles1Request) (*StreamFiles200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StreamFiles200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamFiles1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/files/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamPatchRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	until *string
	allAncestors *string
	since *string
}

// The target revision from which to generate the patch (required)
func (r ApiStreamPatchRequest) Until(until string) ApiStreamPatchRequest {
	r.until = &until
	return r
}

// indicates whether or not to generate a patch which includes all the ancestors of the &#39;until&#39; revision. If true, the value provided by &#39;since&#39; is ignored.
func (r ApiStreamPatchRequest) AllAncestors(allAncestors string) ApiStreamPatchRequest {
	r.allAncestors = &allAncestors
	return r
}

// The base revision from which to generate the patch. This is only applicable when &#39;allAncestors&#39; is false. If omitted the patch will represent one single commit, the &#39;until&#39;.
func (r ApiStreamPatchRequest) Since(since string) ApiStreamPatchRequest {
	r.since = &since
	return r
}

func (r ApiStreamPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.StreamPatchExecute(r)
}

/*
StreamPatch Get patch content at revision

Retrieve the patch content for a repository at a specified revision. 

Cache headers are added to the response (only if full commit hashes are used, not in the case of short hashes). 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamPatchRequest
*/
func (a *RepositoryAPIService) StreamPatch(ctx context.Context, projectKey string, repositorySlug string) ApiStreamPatchRequest {
	return ApiStreamPatchRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) StreamPatchExecute(r ApiStreamPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/patch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "form", "")
	}
	if r.allAncestors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allAncestors", r.allAncestors, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStreamRawRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	at *string
	markup *string
	htmlEscape *string
	includeHeadingId *string
	hardwrap *string
}

// A specific commit or ref to retrieve the raw content at, or the default branch if not specified
func (r ApiStreamRawRequest) At(at string) ApiStreamRawRequest {
	r.at = &at
	return r
}

// If present or \&quot;true\&quot;, triggers the raw content to be markup-rendered and returned as HTML; otherwise, if not specified, or any value other than \&quot;true\&quot;, the content is streamed without markup
func (r ApiStreamRawRequest) Markup(markup string) ApiStreamRawRequest {
	r.markup = &markup
	return r
}

// (Optional) true if HTML should be escaped in the input markup, false otherwise. If not specified, the value of the markup.render.html.escape property, which is true by default, will be used
func (r ApiStreamRawRequest) HtmlEscape(htmlEscape string) ApiStreamRawRequest {
	r.htmlEscape = &htmlEscape
	return r
}

// (Optional) true if headings should contain an ID based on the heading content. If not specified, the value of the markup.render.headerids property, which is false by default, will be used
func (r ApiStreamRawRequest) IncludeHeadingId(includeHeadingId string) ApiStreamRawRequest {
	r.includeHeadingId = &includeHeadingId
	return r
}

// (Optional) Whether the markup implementation should convert newlines to breaks. If not specified, the value of the markup.render.hardwrap property, which is true by default, will be used
func (r ApiStreamRawRequest) Hardwrap(hardwrap string) ApiStreamRawRequest {
	r.hardwrap = &hardwrap
	return r
}

func (r ApiStreamRawRequest) Execute() (*http.Response, error) {
	return r.ApiService.StreamRawExecute(r)
}

/*
StreamRaw Get raw content of a file at revision

Retrieve the raw content for a file path at a specified revision. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The file path to retrieve content from
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamRawRequest
*/
func (a *RepositoryAPIService) StreamRaw(ctx context.Context, path string, projectKey string, repositorySlug string) ApiStreamRawRequest {
	return ApiStreamRawRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) StreamRawExecute(r ApiStreamRawRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamRaw")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/raw/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.at != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "at", r.at, "form", "")
	}
	if r.markup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markup", r.markup, "form", "")
	}
	if r.htmlEscape != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "htmlEscape", r.htmlEscape, "form", "")
	}
	if r.includeHeadingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHeadingId", r.includeHeadingId, "form", "")
	}
	if r.hardwrap != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hardwrap", r.hardwrap, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStreamRawDiffRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	contextLines *string
	srcPath *string
	until *string
	whitespace *string
	since *string
}

// The number of context lines to include around added/removed lines in the diff
func (r ApiStreamRawDiffRequest) ContextLines(contextLines string) ApiStreamRawDiffRequest {
	r.contextLines = &contextLines
	return r
}

// The source path for the file, if it was copied, moved or renamed
func (r ApiStreamRawDiffRequest) SrcPath(srcPath string) ApiStreamRawDiffRequest {
	r.srcPath = &srcPath
	return r
}

// The target revision to diff to (required)
func (r ApiStreamRawDiffRequest) Until(until string) ApiStreamRawDiffRequest {
	r.until = &until
	return r
}

// Optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt;
func (r ApiStreamRawDiffRequest) Whitespace(whitespace string) ApiStreamRawDiffRequest {
	r.whitespace = &whitespace
	return r
}

// The base revision to diff from. If omitted the parent revision of the until revision is used
func (r ApiStreamRawDiffRequest) Since(since string) ApiStreamRawDiffRequest {
	r.since = &since
	return r
}

func (r ApiStreamRawDiffRequest) Execute() (*http.Response, error) {
	return r.ApiService.StreamRawDiffExecute(r)
}

/*
StreamRawDiff Get raw diff for path

Stream the raw diff between two provided revisions. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamRawDiffRequest
*/
func (a *RepositoryAPIService) StreamRawDiff(ctx context.Context, projectKey string, repositorySlug string) ApiStreamRawDiffRequest {
	return ApiStreamRawDiffRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) StreamRawDiffExecute(r ApiStreamRawDiffRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamRawDiff")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contextLines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contextLines", r.contextLines, "form", "")
	}
	if r.srcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "srcPath", r.srcPath, "form", "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "form", "")
	}
	if r.whitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whitespace", r.whitespace, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain; qs=0.1", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStreamRawDiff1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	path string
	projectKey string
	repositorySlug string
	contextLines *string
	srcPath *string
	until *string
	whitespace *string
	since *string
}

// The number of context lines to include around added/removed lines in the diff
func (r ApiStreamRawDiff1Request) ContextLines(contextLines string) ApiStreamRawDiff1Request {
	r.contextLines = &contextLines
	return r
}

// The source path for the file, if it was copied, moved or renamed
func (r ApiStreamRawDiff1Request) SrcPath(srcPath string) ApiStreamRawDiff1Request {
	r.srcPath = &srcPath
	return r
}

// The target revision to diff to (required)
func (r ApiStreamRawDiff1Request) Until(until string) ApiStreamRawDiff1Request {
	r.until = &until
	return r
}

// Optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt;
func (r ApiStreamRawDiff1Request) Whitespace(whitespace string) ApiStreamRawDiff1Request {
	r.whitespace = &whitespace
	return r
}

// The base revision to diff from. If omitted the parent revision of the until revision is used
func (r ApiStreamRawDiff1Request) Since(since string) ApiStreamRawDiff1Request {
	r.since = &since
	return r
}

func (r ApiStreamRawDiff1Request) Execute() (*http.Response, error) {
	return r.ApiService.StreamRawDiff1Execute(r)
}

/*
StreamRawDiff1 Get raw diff for path

Stream the raw diff between two provided revisions. 

The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The path to the file which should be diffed (required)
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiStreamRawDiff1Request
*/
func (a *RepositoryAPIService) StreamRawDiff1(ctx context.Context, path string, projectKey string, repositorySlug string) ApiStreamRawDiff1Request {
	return ApiStreamRawDiff1Request{
		ApiService: a,
		ctx: ctx,
		path: path,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) StreamRawDiff1Execute(r ApiStreamRawDiff1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.StreamRawDiff1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contextLines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contextLines", r.contextLines, "form", "")
	}
	if r.srcPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "srcPath", r.srcPath, "form", "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "form", "")
	}
	if r.whitespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whitespace", r.whitespace, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain; qs=0.1", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSynchronizeRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restRefSyncRequest *RestRefSyncRequest
}

func (r ApiSynchronizeRequest) RestRefSyncRequest(restRefSyncRequest RestRefSyncRequest) ApiSynchronizeRequest {
	r.restRefSyncRequest = &restRefSyncRequest
	return r
}

func (r ApiSynchronizeRequest) Execute() (*RestRejectedRef, *http.Response, error) {
	return r.ApiService.SynchronizeExecute(r)
}

/*
Synchronize Manual synchronization

Allows developers to apply a manual operation to bring a ref back in sync with upstream when it becomes out of sync due to conflicting changes. The following actions are supported:

- <tt>MERGE</tt>: Merges in commits from the upstream ref. After applying this action, the   synchronized ref will be <tt>AHEAD</tt> (as it still includes commits that do not exist   upstream.
   - This action is only supported for <tt>DIVERGED</tt> refs
   - If a "commitMessage" is provided in the context, it will be used on the merge commit.      Otherwise a default message is used.
- <tt>DISCARD</tt>: <i>Throws away</i> local changes in favour of those made upstream. This is a   <i>destructive</i> operation where commits in the local repository are lost.
   - No context entries are supported for this action
   - If the upstream ref has been deleted, the local ref is deleted as well
   - Otherwise, the local ref is updated to reference the same commit as upstream, even if      the update is not fast-forward (similar to a forced push)


The authenticated user must have <b>REPO_WRITE</b> permission for the specified repository. Anonymous users cannot synchronize refs, even on public repositories. Additionally, synchronization must be <i>enabled</i> and <i>available</i> for the specified repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiSynchronizeRequest
*/
func (a *RepositoryAPIService) Synchronize(ctx context.Context, projectKey string, repositorySlug string) ApiSynchronizeRequest {
	return ApiSynchronizeRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRejectedRef
func (a *RepositoryAPIService) SynchronizeExecute(r ApiSynchronizeRequest) (*RestRejectedRef, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRejectedRef
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Synchronize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}/synchronize"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restRefSyncRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestWebhook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	webhookId *int32
	sslVerificationRequired *string
	url *string
	restWebhookCredentials *RestWebhookCredentials
}

func (r ApiTestWebhook1Request) WebhookId(webhookId int32) ApiTestWebhook1Request {
	r.webhookId = &webhookId
	return r
}

// Whether SSL verification is required for the specified webhook URL. Default value is  &lt;code&gt;true&lt;/code&gt;.
func (r ApiTestWebhook1Request) SslVerificationRequired(sslVerificationRequired string) ApiTestWebhook1Request {
	r.sslVerificationRequired = &sslVerificationRequired
	return r
}

// The url in which to connect to
func (r ApiTestWebhook1Request) Url(url string) ApiTestWebhook1Request {
	r.url = &url
	return r
}

// Basic authentication credentials, if required.
func (r ApiTestWebhook1Request) RestWebhookCredentials(restWebhookCredentials RestWebhookCredentials) ApiTestWebhook1Request {
	r.restWebhookCredentials = &restWebhookCredentials
	return r
}

func (r ApiTestWebhook1Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.TestWebhook1Execute(r)
}

/*
TestWebhook1 Test webhook

Test connectivity to a specific endpoint. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiTestWebhook1Request
*/
func (a *RepositoryAPIService) TestWebhook1(ctx context.Context, projectKey string, repositorySlug string) ApiTestWebhook1Request {
	return ApiTestWebhook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return interface{}
func (a *RepositoryAPIService) TestWebhook1Execute(r ApiTestWebhook1Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.TestWebhook1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/test"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.webhookId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webhookId", r.webhookId, "form", "")
	}
	if r.sslVerificationRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sslVerificationRequired", r.sslVerificationRequired, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restWebhookCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnReactRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commentId string
	commitId string
	emoticon string
	repositorySlug string
}

func (r ApiUnReactRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnReactExecute(r)
}

/*
UnReact Remove a reaction from comment

Remove an emoticon reaction from a comment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param commentId The comment id
 @param commitId The commit id
 @param emoticon The emoticon to remove
 @param repositorySlug The repository slug.
 @return ApiUnReactRequest
*/
func (a *RepositoryAPIService) UnReact(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) ApiUnReactRequest {
	return ApiUnReactRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commentId: commentId,
		commitId: commitId,
		emoticon: emoticon,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) UnReactExecute(r ApiUnReactRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.UnReact")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"emoticon"+"}", url.PathEscape(parameterValueToString(r.emoticon, "emoticon")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnwatchRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
}

func (r ApiUnwatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnwatchExecute(r)
}

/*
Unwatch Stop watching commit

Remove the authenticated user as a watcher for the specified commit.

The authenticated user must have <strong>REPO_READ</strong> permission for the repository containing the commit to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiUnwatchRequest
*/
func (a *RepositoryAPIService) Unwatch(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiUnwatchRequest {
	return ApiUnwatchRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) UnwatchExecute(r ApiUnwatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Unwatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnwatch2Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
}

func (r ApiUnwatch2Request) Execute() (*http.Response, error) {
	return r.ApiService.Unwatch2Execute(r)
}

/*
Unwatch2 Stop watching repository

Remove the authenticated user as a watcher for the specified repository. 

The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiUnwatch2Request
*/
func (a *RepositoryAPIService) Unwatch2(ctx context.Context, projectKey string, repositorySlug string) ApiUnwatch2Request {
	return ApiUnwatch2Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) Unwatch2Execute(r ApiUnwatch2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Unwatch2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCommentRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commentId string
	commitId string
	repositorySlug string
	restComment *RestComment
}

// The comment to update
func (r ApiUpdateCommentRequest) RestComment(restComment RestComment) ApiUpdateCommentRequest {
	r.restComment = &restComment
	return r
}

func (r ApiUpdateCommentRequest) Execute() (*RestComment, *http.Response, error) {
	return r.ApiService.UpdateCommentExecute(r)
}

/*
UpdateComment Update a commit comment

Update a comment, with the following restrictions:

- only the author of the comment may update the <i>text</i> of the comment
- only the author of the comment or repository admins and above may update the other   fields of a comment


<strong>Note:</strong> the supplied supplied JSON object must contain a <code>version</code> that must match the server's version of the comment or the update will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the update. Look for the 'version' attribute in the returned JSON structure.

The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commentId The ID of the comment to retrieve
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiUpdateCommentRequest
*/
func (a *RepositoryAPIService) UpdateComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) ApiUpdateCommentRequest {
	return ApiUpdateCommentRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commentId: commentId,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestComment
func (a *RepositoryAPIService) UpdateCommentExecute(r ApiUpdateCommentRequest) (*RestComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.UpdateComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefaultTask1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	taskId string
	restDefaultTaskRequest *RestDefaultTaskRequest
}

// The task to be updated
func (r ApiUpdateDefaultTask1Request) RestDefaultTaskRequest(restDefaultTaskRequest RestDefaultTaskRequest) ApiUpdateDefaultTask1Request {
	r.restDefaultTaskRequest = &restDefaultTaskRequest
	return r
}

func (r ApiUpdateDefaultTask1Request) Execute() (*RestDefaultTask, *http.Response, error) {
	return r.ApiService.UpdateDefaultTask1Execute(r)
}

/*
UpdateDefaultTask1 Update a default task

Updates a default task for the supplied repository.

The authenticated user must have **REPO_ADMIN** permission for this repository to call the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @param taskId The ID of the default task
 @return ApiUpdateDefaultTask1Request
*/
func (a *RepositoryAPIService) UpdateDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, taskId string) ApiUpdateDefaultTask1Request {
	return ApiUpdateDefaultTask1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return RestDefaultTask
func (a *RepositoryAPIService) UpdateDefaultTask1Execute(r ApiUpdateDefaultTask1Request) (*RestDefaultTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestDefaultTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.UpdateDefaultTask1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/default-tasks/latest/projects/{projectKey}/repos/{repositorySlug}/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restDefaultTaskRequest == nil {
		return localVarReturnValue, nil, reportError("restDefaultTaskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restDefaultTaskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePullRequestSettings1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restRepositoryPullRequestSettings *RestRepositoryPullRequestSettings
}

// The updated settings.
func (r ApiUpdatePullRequestSettings1Request) RestRepositoryPullRequestSettings(restRepositoryPullRequestSettings RestRepositoryPullRequestSettings) ApiUpdatePullRequestSettings1Request {
	r.restRepositoryPullRequestSettings = &restRepositoryPullRequestSettings
	return r
}

func (r ApiUpdatePullRequestSettings1Request) Execute() (*RestRepositoryPullRequestSettings, *http.Response, error) {
	return r.ApiService.UpdatePullRequestSettings1Execute(r)
}

/*
UpdatePullRequestSettings1 Update pull request settings

Update the pull request settings for the context repository. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the context repository to call this resource. 

This resource will call all RestFragments that are registered with the key <strong>bitbucket.repository.settings.pullRequests</strong>. If any fragment fails validations by returning a non-empty Map of errors, then no fragments will execute. 

Only the settings that should be updated need to be included in the request. 

The property keys for the settings that are bundled with the application are 

- mergeConfig - the merge strategy configuration for pull requests
- requiredApprovers - (Deprecated, please use com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook instead) the number of approvals required on a pull request for it to be mergeable, or 0 to disable the merge check
- com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook - a json map containing the keys 'enabled' (a boolean to enable or disable this merge check) and 'count' (an integer to set the number of required approvals)
- requiredAllApprovers - whether or not all approvers must approve a pull request for it to be mergeable
- requiredAllTasksComplete - whether or not all tasks on a pull request need to be completed for it to be mergeable
- requiredSuccessfulBuilds - (Deprecated, please use com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck instead) the number of successful builds on a pull request for it to be mergeable, or 0 to disable the merge check
- com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck - a json map containing the keys 'enabled' (a boolean to enable or disable this merge check) and 'count' (an integer to set the number of required builds)


<strong>Merge strategy configuration deletion:</strong>

An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty "mergeConfig" attribute. i.e: 


```{ 
    "mergeConfig": { 
    } 
} 
```

Upon completion of this request, the effective configuration will be: 

- The configuration set for this repository's SCM type as set at the project level, if present, otherwise
- the configuration set for this repository's SCM type as set at the instance level, if present, otherwise
- the default configuration for this repository's SCM type




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiUpdatePullRequestSettings1Request
*/
func (a *RepositoryAPIService) UpdatePullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string) ApiUpdatePullRequestSettings1Request {
	return ApiUpdatePullRequestSettings1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestRepositoryPullRequestSettings
func (a *RepositoryAPIService) UpdatePullRequestSettings1Execute(r ApiUpdatePullRequestSettings1Request) (*RestRepositoryPullRequestSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestRepositoryPullRequestSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.UpdatePullRequestSettings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restRepositoryPullRequestSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebhook1Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	webhookId string
	repositorySlug string
	restWebhook *RestWebhook
}

// The representation of the updated values for the webhook
func (r ApiUpdateWebhook1Request) RestWebhook(restWebhook RestWebhook) ApiUpdateWebhook1Request {
	r.restWebhook = &restWebhook
	return r
}

func (r ApiUpdateWebhook1Request) Execute() (*RestWebhook, *http.Response, error) {
	return r.ApiService.UpdateWebhook1Execute(r)
}

/*
UpdateWebhook1 Update webhook

Update an existing webhook. 

The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param webhookId Id of the existing webhook
 @param repositorySlug The repository slug.
 @return ApiUpdateWebhook1Request
*/
func (a *RepositoryAPIService) UpdateWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) ApiUpdateWebhook1Request {
	return ApiUpdateWebhook1Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		webhookId: webhookId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
//  @return RestWebhook
func (a *RepositoryAPIService) UpdateWebhook1Execute(r ApiUpdateWebhook1Request) (*RestWebhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestWebhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.UpdateWebhook1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhookId"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restWebhook
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchRequest struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	commitId string
	repositorySlug string
}

func (r ApiWatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.WatchExecute(r)
}

/*
Watch Watch commit

Add the authenticated user as a watcher for the specified commit.

The authenticated user must have <strong>REPO_READ</strong> permission for the repository containing the commit to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key
 @param commitId The <i>full ID</i> of the commit within the repository
 @param repositorySlug The repository slug
 @return ApiWatchRequest
*/
func (a *RepositoryAPIService) Watch(ctx context.Context, projectKey string, commitId string, repositorySlug string) ApiWatchRequest {
	return ApiWatchRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		commitId: commitId,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) WatchExecute(r ApiWatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Watch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commitId"+"}", url.PathEscape(parameterValueToString(r.commitId, "commitId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWatch2Request struct {
	ctx context.Context
	ApiService *RepositoryAPIService
	projectKey string
	repositorySlug string
	restRepository *RestRepository
}

// The repository to watch.
func (r ApiWatch2Request) RestRepository(restRepository RestRepository) ApiWatch2Request {
	r.restRepository = &restRepository
	return r
}

func (r ApiWatch2Request) Execute() (*http.Response, error) {
	return r.ApiService.Watch2Execute(r)
}

/*
Watch2 Watch repository

Add the authenticated user as a watcher for the specified repository. 

The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectKey The project key.
 @param repositorySlug The repository slug.
 @return ApiWatch2Request
*/
func (a *RepositoryAPIService) Watch2(ctx context.Context, projectKey string, repositorySlug string) ApiWatch2Request {
	return ApiWatch2Request{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		repositorySlug: repositorySlug,
	}
}

// Execute executes the request
func (a *RepositoryAPIService) Watch2Execute(r ApiWatch2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryAPIService.Watch2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectKey"+"}", url.PathEscape(parameterValueToString(r.projectKey, "projectKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositorySlug"+"}", url.PathEscape(parameterValueToString(r.repositorySlug, "repositorySlug")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAllAccessTokens401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
